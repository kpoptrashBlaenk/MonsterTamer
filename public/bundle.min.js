(() => {
  // src/lib/phaser.ts
  var phaser_default = window.Phaser;

  // src/lib/scenes/scene-keys.ts
  var SCENE_KEYS = Object.freeze({
    PRELOAD_SCENE: "PRELOAD_SCENE",
    BATTLE_SCENE: "BATTLE_SCENE",
    TITLE_SCENE: "TITLE_SCENE"
  });

  // src/assets/asset-keys.ts
  var BATTLE_BACKGROUND_ASSET_KEYS = Object.freeze({
    FOREST: "FOREST"
  });
  var MONSTER_ASSET_KEYS = Object.freeze({
    IGUANIGNITE: "IGUANIGNITE",
    CARNODUSK: "CARNODUSK"
  });
  var BATTLE_ASSET_KEYS = Object.freeze({
    HEALTH_BAR_BACKGROUND: "HEALTH_BAR_BACKGROUND"
  });
  var HEALTH_BAR_ASSET_KEYS = Object.freeze({
    LEFT_CAP: "LEFT_CAP",
    RIGHT_CAP: "RIGHT_CAP",
    MIDDLE: "MIDDLE",
    LEFT_CAP_SHADOW: "LEFT_CAP_SHADOW",
    RIGHT_CAP_SHADOW: "RIGHT_CAP_SHADOW",
    MIDDLE_SHADOW: "MIDDLE_SHADOW"
  });
  var UI_ASSET_KEYS = Object.freeze({
    CURSOR: "CURSOR",
    MENU_BACKGROUND: "MENU_BACKGROUND"
  });
  var DATA_ASSET_KEYS = Object.freeze({
    ATTACKS: "ATTACKS",
    ANIMATIONS: "ANIMATIONS"
  });
  var ATTACK_ASSET_KEYS = Object.freeze({
    ICE_SHARD: "ICE_SHARD",
    ICE_SHARD_START: "ICE_SHARD_START",
    SLASH: "SLASH"
  });
  var TITLE_ASSET_KEYS = Object.freeze({
    BACKGROUND: "BACKGROUND",
    TITLE: "TITLE",
    PANEL: "PANEL"
  });

  // src/assets/font-keys.ts
  var CUSTOM_FONTS = Object.freeze({
    KENNEY: "Kenney-Future-Narrow",
    POKEROGUE: "PokeRogue"
  });

  // src/lib/webfontloader.ts
  var webfontloader_default = window.WebFont;

  // src/assets/web-font-file-loader.ts
  var WebFontFileLoader = class extends phaser_default.Loader.File {
    fontNames;
    constructor(loader, fontNames) {
      super(loader, {
        type: "webfont",
        key: fontNames.toString()
      });
      this.fontNames = fontNames;
    }
    load() {
      webfontloader_default.load({
        custom: {
          families: this.fontNames
        },
        active: () => {
          this.loader.nextFile(this, true);
        },
        inactive: () => {
          console.error(`Failed to load custom fonts ${JSON.stringify(this.fontNames)}`);
          this.loader.nextFile(this, false);
        }
      });
    }
  };

  // src/utils/data-utils.ts
  var DataUtils = class {
    static getMonsterAttack(scene, attackId) {
      const data = scene.cache.json.get(DATA_ASSET_KEYS.ATTACKS);
      return data.find((attack) => attack.id === attackId);
    }
    static getAnimations(scene) {
      return scene.cache.json.get(DATA_ASSET_KEYS.ANIMATIONS);
    }
  };

  // src/lib/scenes/preload-scene.ts
  var PreloadScene = class extends phaser_default.Scene {
    constructor() {
      super({
        key: SCENE_KEYS.PRELOAD_SCENE
      });
    }
    preload() {
      const monsterTamerAssetPath = "../assets/images/monster-tamer";
      const kenneysAssetPath = "../assets/images/kenneys-assets";
      const pimenAssetPath = "../assets/images/pimen";
      this.load.image(TITLE_ASSET_KEYS.BACKGROUND, `${monsterTamerAssetPath}/ui/title/background.png`);
      this.load.image(TITLE_ASSET_KEYS.PANEL, `${monsterTamerAssetPath}/ui/title/title_background.png`);
      this.load.image(TITLE_ASSET_KEYS.TITLE, `${monsterTamerAssetPath}/ui/title/title_text.png`);
      this.load.image(BATTLE_BACKGROUND_ASSET_KEYS.FOREST, `${monsterTamerAssetPath}/battle-backgrounds/forest-background.png`);
      this.load.image(BATTLE_ASSET_KEYS.HEALTH_BAR_BACKGROUND, `${kenneysAssetPath}/ui-space-expansion/custom-ui.png`);
      this.load.image(HEALTH_BAR_ASSET_KEYS.RIGHT_CAP, `${kenneysAssetPath}/ui-space-expansion/barHorizontal_green_right.png`);
      this.load.image(HEALTH_BAR_ASSET_KEYS.MIDDLE, `${kenneysAssetPath}/ui-space-expansion/barHorizontal_green_mid.png`);
      this.load.image(HEALTH_BAR_ASSET_KEYS.LEFT_CAP, `${kenneysAssetPath}/ui-space-expansion/barHorizontal_green_left.png`);
      this.load.image(HEALTH_BAR_ASSET_KEYS.RIGHT_CAP_SHADOW, `${kenneysAssetPath}/ui-space-expansion/barHorizontal_shadow_right.png`);
      this.load.image(HEALTH_BAR_ASSET_KEYS.MIDDLE_SHADOW, `${kenneysAssetPath}/ui-space-expansion/barHorizontal_shadow_mid.png`);
      this.load.image(HEALTH_BAR_ASSET_KEYS.LEFT_CAP_SHADOW, `${kenneysAssetPath}/ui-space-expansion/barHorizontal_shadow_left.png`);
      this.load.image(MONSTER_ASSET_KEYS.CARNODUSK, `${monsterTamerAssetPath}/monsters/carnodusk.png`);
      this.load.image(MONSTER_ASSET_KEYS.IGUANIGNITE, `${monsterTamerAssetPath}/monsters/iguanignite.png`);
      this.load.image(UI_ASSET_KEYS.CURSOR, `${monsterTamerAssetPath}/ui/cursor.png`);
      this.load.image(UI_ASSET_KEYS.MENU_BACKGROUND, `${kenneysAssetPath}/ui-space-expansion/glassPanel.png`);
      this.load.json(DATA_ASSET_KEYS.ATTACKS, "assets/data/attacks.json");
      this.load.json(DATA_ASSET_KEYS.ANIMATIONS, "assets/data/animations.json");
      this.load.addFile(new WebFontFileLoader(this.load, [CUSTOM_FONTS.POKEROGUE]));
      this.load.spritesheet(ATTACK_ASSET_KEYS.ICE_SHARD, `${pimenAssetPath}/ice-attack/active.png`, {
        frameWidth: 32,
        frameHeight: 32
      });
      this.load.spritesheet(ATTACK_ASSET_KEYS.ICE_SHARD_START, `${pimenAssetPath}/ice-attack/start.png`, {
        frameWidth: 32,
        frameHeight: 32
      });
      this.load.spritesheet(ATTACK_ASSET_KEYS.SLASH, `${pimenAssetPath}/slash.png`, {
        frameWidth: 48,
        frameHeight: 48
      });
    }
    create() {
      this.createAnimations();
      this.scene.start(SCENE_KEYS.TITLE_SCENE);
    }
    createAnimations() {
      const animations = DataUtils.getAnimations(this);
      animations.forEach((animation) => {
        const frames = animation.frames ? this.anims.generateFrameNumbers(animation.assetKey, {frames: animation.frames}) : this.anims.generateFrameNumbers(animation.assetKey);
        this.anims.create({
          key: animation.key,
          frames,
          frameRate: animation.frameRate,
          repeat: animation.repeat,
          delay: animation.delay,
          yoyo: animation.yoyo
        });
      });
    }
  };

  // src/common/direction.ts
  var DIRECTION = Object.freeze({
    LEFT: "LEFT",
    RIGHT: "RIGHT",
    UP: "UP",
    DOWN: "DOWN",
    NONE: "NONE"
  });

  // src/utils/controls.ts
  var Controls = class {
    scene;
    cursorKeys;
    lockPlayerInput;
    constructor(scene) {
      this.scene = scene;
      this.cursorKeys = this.scene.input.keyboard?.createCursorKeys();
      this.lockPlayerInput = false;
    }
    getIsInputLocked() {
      return this.lockPlayerInput;
    }
    setLockInput(value) {
      this.lockPlayerInput = value;
    }
    wasSpaceKeyPressed() {
      if (this.cursorKeys === void 0) {
        return false;
      }
      return phaser_default.Input.Keyboard.JustDown(this.cursorKeys.space);
    }
    wasBackKeyPressed() {
      if (this.cursorKeys === void 0) {
        return false;
      }
      return phaser_default.Input.Keyboard.JustDown(this.cursorKeys.shift);
    }
    getDirectionKeyPressedDown() {
      if (this.cursorKeys === void 0) {
        return DIRECTION.NONE;
      }
      let selectedDirection = DIRECTION.NONE;
      if (this.cursorKeys.left.isDown) {
        selectedDirection = DIRECTION.LEFT;
      } else if (this.cursorKeys.right.isDown) {
        selectedDirection = DIRECTION.RIGHT;
      } else if (this.cursorKeys.up.isDown) {
        selectedDirection = DIRECTION.UP;
      } else if (this.cursorKeys.down.isDown) {
        selectedDirection = DIRECTION.DOWN;
      }
      return selectedDirection;
    }
    getDirectionKeyJustDown() {
      if (this.cursorKeys === void 0) {
        return DIRECTION.NONE;
      }
      let selectedDirection = DIRECTION.NONE;
      if (phaser_default.Input.Keyboard.JustDown(this.cursorKeys.left)) {
        selectedDirection = DIRECTION.LEFT;
      } else if (phaser_default.Input.Keyboard.JustDown(this.cursorKeys.right)) {
        selectedDirection = DIRECTION.RIGHT;
      } else if (phaser_default.Input.Keyboard.JustDown(this.cursorKeys.up)) {
        selectedDirection = DIRECTION.UP;
      } else if (phaser_default.Input.Keyboard.JustDown(this.cursorKeys.down)) {
        selectedDirection = DIRECTION.DOWN;
      }
      return selectedDirection;
    }
  };

  // src/utils/guard.ts
  function exhaustiveGuard(_value) {
    throw new Error(`Error! Reached forbidden guard function with unexpected value: ${JSON.stringify(_value)}`);
  }

  // src/utils/nine-slice.ts
  var ASSET_CUT_FRAMES = Object.freeze({
    TL: "TL",
    TM: "TM",
    TR: "TR",
    ML: "ML",
    MM: "MM",
    MR: "MR",
    BL: "BL",
    BM: "BM",
    BR: "BR"
  });
  var NineSlice = class {
    cornerCutSize;
    assetKey;
    constructor(config) {
      this.cornerCutSize = config.cornerCutSize;
      this.assetKey = config.assetKey;
      this.createNineSliceTextures(config.textureManager, config.assetKey);
    }
    createNineSliceTextures(textureManager, assetKey) {
      const methodName = "createNineSliceTextures";
      const texture = textureManager.get(assetKey);
      if (texture.key === "__MISSING") {
        console.warn(`[${NineSlice.name}:${methodName}] the provided texture asset Key was not found`);
        return;
      }
      if (texture.getFrameNames(false).length !== 0) {
        return;
      }
      const baseFrame = texture.frames["__BASE"];
      texture.add(ASSET_CUT_FRAMES.TL, 0, 0, 0, this.cornerCutSize, this.cornerCutSize);
      texture.add(ASSET_CUT_FRAMES.TM, 0, this.cornerCutSize, 0, baseFrame.width - this.cornerCutSize * 2, this.cornerCutSize);
      texture.add(ASSET_CUT_FRAMES.TR, 0, baseFrame.width - this.cornerCutSize, 0, this.cornerCutSize, this.cornerCutSize);
      texture.add(ASSET_CUT_FRAMES.ML, 0, 0, this.cornerCutSize, this.cornerCutSize, baseFrame.height - this.cornerCutSize * 2);
      texture.add(ASSET_CUT_FRAMES.MM, 0, this.cornerCutSize, this.cornerCutSize, baseFrame.width - this.cornerCutSize * 2, baseFrame.height - this.cornerCutSize * 2);
      texture.add(ASSET_CUT_FRAMES.MR, 0, baseFrame.width - this.cornerCutSize, this.cornerCutSize, this.cornerCutSize, baseFrame.height - this.cornerCutSize * 2);
      texture.add(ASSET_CUT_FRAMES.BL, 0, 0, baseFrame.height - this.cornerCutSize, this.cornerCutSize, this.cornerCutSize);
      texture.add(ASSET_CUT_FRAMES.BM, 0, this.cornerCutSize, baseFrame.height - this.cornerCutSize, baseFrame.width - this.cornerCutSize * 2, this.cornerCutSize);
      texture.add(ASSET_CUT_FRAMES.BR, 0, baseFrame.width - this.cornerCutSize, baseFrame.height - this.cornerCutSize, this.cornerCutSize, this.cornerCutSize);
    }
    createNineSliceContainer(scene, targetWidth, targetHeight) {
      const tl = scene.add.image(0, 0, this.assetKey, ASSET_CUT_FRAMES.TL).setOrigin(0);
      const tm = scene.add.image(tl.displayWidth, 0, this.assetKey, ASSET_CUT_FRAMES.TM).setOrigin(0);
      tm.displayWidth = targetWidth - this.cornerCutSize * 2;
      const tr = scene.add.image(tl.displayWidth + tm.displayWidth, 0, this.assetKey, ASSET_CUT_FRAMES.TR).setOrigin(0);
      const ml = scene.add.image(0, tl.displayHeight, this.assetKey, ASSET_CUT_FRAMES.ML).setOrigin(0);
      ml.displayHeight = targetHeight - this.cornerCutSize * 2;
      const mm = scene.add.image(ml.displayWidth, ml.y, this.assetKey, ASSET_CUT_FRAMES.MM).setOrigin(0);
      mm.displayHeight = targetHeight - this.cornerCutSize * 2;
      mm.displayWidth = targetWidth - this.cornerCutSize * 2;
      const mr = scene.add.image(ml.displayWidth + mm.displayWidth, ml.y, this.assetKey, ASSET_CUT_FRAMES.MR).setOrigin(0);
      mr.displayHeight = mm.displayHeight;
      const bl = scene.add.image(0, tl.displayHeight + ml.displayHeight, this.assetKey, ASSET_CUT_FRAMES.BL).setOrigin(0);
      const bm = scene.add.image(bl.displayWidth, bl.y, this.assetKey, ASSET_CUT_FRAMES.BM).setOrigin(0);
      bm.displayWidth = tm.displayWidth;
      const br = scene.add.image(bl.displayWidth + bm.displayWidth, bl.y, this.assetKey, ASSET_CUT_FRAMES.BR).setOrigin(0);
      return scene.add.container(0, 0, [tl, tm, tr, ml, mm, mr, bl, bm, br]);
    }
  };

  // src/lib/scenes/title-scene.ts
  var MENU_TEXT_STYLE = Object.freeze({
    fontFamily: CUSTOM_FONTS.POKEROGUE,
    color: "4D4A49",
    fontSize: "35px"
  });
  var PLAYER_INPUT_CURSOR_POSITION = Object.freeze({
    x: 170,
    y: 41
  });
  var MAIN_MENU_OPTIONS = Object.freeze({
    NEW_GAME: "NEW_GAME",
    CONTINUE: "CONTINUE",
    OPTIONS: "OPTIONS"
  });
  var TitleScene = class extends phaser_default.Scene {
    mainMenuCursorPhaserImageGameObject;
    controls;
    selectedMenuOption;
    isContinueButtonEnabled;
    nineSliceMenu;
    constructor() {
      super({
        key: SCENE_KEYS.TITLE_SCENE
      });
    }
    init() {
      this.nineSliceMenu = new NineSlice({
        cornerCutSize: 32,
        textureManager: this.sys.textures,
        assetKey: UI_ASSET_KEYS.MENU_BACKGROUND
      });
    }
    create() {
      this.selectedMenuOption = MAIN_MENU_OPTIONS.NEW_GAME;
      this.isContinueButtonEnabled = false;
      this.add.image(0, 0, TITLE_ASSET_KEYS.BACKGROUND).setOrigin(0).setScale(0.58);
      this.add.image(this.scale.width / 2, 150, TITLE_ASSET_KEYS.PANEL).setScale(0.25, 0.25).setAlpha(0.5);
      this.add.image(this.scale.width / 2, 150, TITLE_ASSET_KEYS.TITLE).setScale(0.55).setAlpha(0.5);
      const menuBgWidth = 500;
      const menuBgContainer = this.nineSliceMenu.createNineSliceContainer(this, menuBgWidth, 200);
      const newGameText = this.add.text(menuBgWidth / 2, 40, "New Game", MENU_TEXT_STYLE).setOrigin(0.5);
      const continueText = this.add.text(menuBgWidth / 2, 90, "Continue", MENU_TEXT_STYLE).setOrigin(0.5);
      if (!this.isContinueButtonEnabled) {
        continueText.setAlpha(0.5);
      }
      const optionsText = this.add.text(menuBgWidth / 2, 140, "Options", MENU_TEXT_STYLE).setOrigin(0.5);
      const menuContainer = this.add.container(0, 0, [menuBgContainer, newGameText, continueText, optionsText]);
      menuContainer.setPosition(this.scale.width / 2 - menuBgWidth / 2, 300);
      this.mainMenuCursorPhaserImageGameObject = this.add.image(PLAYER_INPUT_CURSOR_POSITION.x, PLAYER_INPUT_CURSOR_POSITION.y, UI_ASSET_KEYS.CURSOR).setOrigin(0.5).setScale(2.5);
      menuContainer.add(this.mainMenuCursorPhaserImageGameObject);
      this.add.tween({
        delay: 0,
        duration: 500,
        repeat: -1,
        x: {
          from: PLAYER_INPUT_CURSOR_POSITION.x,
          start: PLAYER_INPUT_CURSOR_POSITION.x,
          to: PLAYER_INPUT_CURSOR_POSITION.x + 3
        },
        targets: this.mainMenuCursorPhaserImageGameObject
      });
      this.cameras.main.once(phaser_default.Cameras.Scene2D.Events.FADE_OUT_COMPLETE, () => {
        if (this.selectedMenuOption === MAIN_MENU_OPTIONS.NEW_GAME) {
          this.scene.start(SCENE_KEYS.BATTLE_SCENE);
          return;
        }
        if (this.selectedMenuOption === MAIN_MENU_OPTIONS.CONTINUE) {
          this.scene.start(SCENE_KEYS.BATTLE_SCENE);
          return;
        }
        if (this.selectedMenuOption === MAIN_MENU_OPTIONS.OPTIONS) {
          this.scene.start(SCENE_KEYS.BATTLE_SCENE);
        }
      });
      this.controls = new Controls(this);
    }
    update() {
      if (this.controls.getIsInputLocked()) {
        return;
      }
      const wasSpaceKeyPressed = this.controls.wasSpaceKeyPressed();
      if (wasSpaceKeyPressed) {
        this.cameras.main.fadeOut(500, 0, 0, 0);
        this.controls.setLockInput(true);
        return;
      }
      let selectedDirection = this.controls.getDirectionKeyJustDown();
      if (selectedDirection !== DIRECTION.NONE) {
        this.moveMenuSelectCursor(selectedDirection);
      }
    }
    moveMenuSelectCursor(direction) {
      this.updateSelectedOptionFromInput(direction);
      switch (this.selectedMenuOption) {
        case MAIN_MENU_OPTIONS.NEW_GAME:
          this.mainMenuCursorPhaserImageGameObject.setY(PLAYER_INPUT_CURSOR_POSITION.y);
          break;
        case MAIN_MENU_OPTIONS.CONTINUE:
          this.mainMenuCursorPhaserImageGameObject.setY(91);
          break;
        case MAIN_MENU_OPTIONS.OPTIONS:
          this.mainMenuCursorPhaserImageGameObject.setY(141);
          break;
        default:
          exhaustiveGuard(this.selectedMenuOption);
      }
    }
    updateSelectedOptionFromInput(direction) {
      switch (direction) {
        case DIRECTION.UP:
          if (this.selectedMenuOption === MAIN_MENU_OPTIONS.NEW_GAME) {
            return;
          }
          if (this.selectedMenuOption === MAIN_MENU_OPTIONS.CONTINUE) {
            this.selectedMenuOption = MAIN_MENU_OPTIONS.NEW_GAME;
            return;
          }
          if (this.selectedMenuOption === MAIN_MENU_OPTIONS.OPTIONS && !this.isContinueButtonEnabled) {
            this.selectedMenuOption = MAIN_MENU_OPTIONS.NEW_GAME;
            return;
          }
          if (this.selectedMenuOption === MAIN_MENU_OPTIONS.OPTIONS) {
            this.selectedMenuOption = MAIN_MENU_OPTIONS.CONTINUE;
            return;
          }
          return;
        case DIRECTION.DOWN:
          if (this.selectedMenuOption === MAIN_MENU_OPTIONS.NEW_GAME && !this.isContinueButtonEnabled) {
            this.selectedMenuOption = MAIN_MENU_OPTIONS.OPTIONS;
            return;
          }
          if (this.selectedMenuOption === MAIN_MENU_OPTIONS.NEW_GAME) {
            this.selectedMenuOption = MAIN_MENU_OPTIONS.CONTINUE;
            return;
          }
          if (this.selectedMenuOption === MAIN_MENU_OPTIONS.CONTINUE) {
            this.selectedMenuOption = MAIN_MENU_OPTIONS.OPTIONS;
            return;
          }
          if (this.selectedMenuOption === MAIN_MENU_OPTIONS.OPTIONS) {
            return;
          }
          return;
        case DIRECTION.LEFT:
        case DIRECTION.RIGHT:
        case DIRECTION.NONE:
          return;
        default:
          exhaustiveGuard(direction);
      }
    }
  };

  // src/battle/ui/battle-menu-options.ts
  var BATTLE_MENU_OPTIONS = Object.freeze({
    FIGHT: "FIGHT",
    SWITCH: "SWITCH",
    ITEM: "ITEM",
    FLEE: "FLEE"
  });
  var ATTACK_MOVE_OPTIONS = Object.freeze({
    MOVE_1: "MOVE_1",
    MOVE_2: "MOVE_2",
    MOVE_3: "MOVE_3",
    MOVE_4: "MOVE_4"
  });
  var ACTIVE_BATTLE_MENU = Object.freeze({
    BATTLE_MAIN: "BATTLE_MAIN",
    BATTLE_MOVE_SELECT: "BATTLE_MOVE_SELECT",
    BATTLE_ITEM: "BATTLE_ITEM",
    BATTLE_SWITCH: "BATTLE_SWITCH",
    BATTLE_FLEE: "BATTLE_FLEE"
  });

  // src/battle/ui/battle-menu-config.ts
  var BATTLE_UI_TEXT_STYLE = Object.freeze({
    fontFamily: CUSTOM_FONTS.POKEROGUE,
    color: "black",
    fontSize: "35px"
  });

  // src/utils/text-utils.ts
  function animateText(scene, target, text, config) {
    const length = text.length;
    let i = 0;
    scene.time.addEvent({
      callback: () => {
        target.text += text[i];
        i++;
        if (i === length - 1 && config?.callback) {
          config.callback();
        }
      },
      repeat: length - 1,
      delay: config?.delay || 50
    });
  }

  // src/config.ts
  var SKIP_BATTLE_ANIMATIONS = false;

  // src/battle/menu/battle-menu.ts
  var BATTLE_MENU_CURSOR_POSITION = Object.freeze({
    x: 42,
    y: 42
  });
  var ATTACK_MENU_CURSOR_POSITION = Object.freeze({
    x: 42,
    y: 42
  });
  var PLAYER_INPUT_CURSOR_POSITION2 = Object.freeze({
    y: 480
  });
  var BattleMenu = class {
    scene;
    mainBattleMenuPhaserContainerGameObject;
    moveSelectionSubMenuPhaserContainerGameObject;
    battleTextGameObjectLine1;
    battleTextGameObjectLine2;
    mainBattleMenuCursorPhaserImageGameObject;
    attackBattleMenuCursorPhaserImageGameObject;
    selectedBattleMenuOption;
    selectedAttackMoveOption;
    activeBattleMenu;
    queuedInfoPanelMessages;
    queuedInfoPanelCallback;
    waitingForPlayerInput;
    selectedAttackIndex;
    activePlayerMonster;
    userInputCursorPhaserImageObject;
    userInputCursorPhaserTween;
    queuedMessagesSkipAnimation;
    queuedMessageAnimationPlaying;
    constructor(scene, activePlayerMonster) {
      this.scene = scene;
      this.activePlayerMonster = activePlayerMonster;
      this.activeBattleMenu = ACTIVE_BATTLE_MENU.BATTLE_MAIN;
      this.selectedBattleMenuOption = BATTLE_MENU_OPTIONS.FIGHT;
      this.selectedAttackMoveOption = ATTACK_MOVE_OPTIONS.MOVE_1;
      this.queuedInfoPanelCallback = void 0;
      this.queuedInfoPanelMessages = [];
      this.waitingForPlayerInput = false;
      this.selectedAttackIndex = void 0;
      this.queuedMessagesSkipAnimation = false;
      this.queuedMessageAnimationPlaying = false;
      this.createMainInfoPane();
      this.createMainBattleMenu();
      this.createMonsterAttackSubMenu();
      this.createPlayerInputCursor();
      this.hideMonsterAttackSubMenu();
      this.hideMainBattleMenu();
    }
    get selectedAttack() {
      if (this.activeBattleMenu === ACTIVE_BATTLE_MENU.BATTLE_MOVE_SELECT) {
        return this.selectedAttackIndex;
      }
      return void 0;
    }
    showMainBattleMenu() {
      this.activeBattleMenu = ACTIVE_BATTLE_MENU.BATTLE_MAIN;
      this.battleTextGameObjectLine1.setText("What should");
      this.mainBattleMenuPhaserContainerGameObject.setAlpha(1);
      this.battleTextGameObjectLine1.setAlpha(1);
      this.battleTextGameObjectLine2.setAlpha(1);
      this.selectedBattleMenuOption = BATTLE_MENU_OPTIONS.FIGHT;
      this.mainBattleMenuCursorPhaserImageGameObject.setPosition(BATTLE_MENU_CURSOR_POSITION.x, BATTLE_MENU_CURSOR_POSITION.y);
      this.selectedAttackIndex = void 0;
    }
    hideMainBattleMenu() {
      this.mainBattleMenuPhaserContainerGameObject.setAlpha(0);
      this.battleTextGameObjectLine1.setAlpha(0);
      this.battleTextGameObjectLine2.setAlpha(0);
    }
    showMonsterAttackSubMenu() {
      this.activeBattleMenu = ACTIVE_BATTLE_MENU.BATTLE_MOVE_SELECT;
      this.moveSelectionSubMenuPhaserContainerGameObject.setAlpha(1);
    }
    hideMonsterAttackSubMenu() {
      this.activeBattleMenu = ACTIVE_BATTLE_MENU.BATTLE_MAIN;
      this.moveSelectionSubMenuPhaserContainerGameObject.setAlpha(0);
    }
    playInputCursorAnimation() {
      this.userInputCursorPhaserImageObject.setPosition(this.battleTextGameObjectLine1.displayWidth + this.userInputCursorPhaserImageObject.displayWidth * 3.5, this.userInputCursorPhaserImageObject.y).setAlpha(1);
      this.userInputCursorPhaserTween.restart();
    }
    hideInputCursor() {
      this.userInputCursorPhaserImageObject.setAlpha(0);
      this.userInputCursorPhaserTween.pause();
    }
    handlePlayerInput(input) {
      if (this.queuedMessageAnimationPlaying && input === "OK") {
        return;
      }
      if (this.waitingForPlayerInput && (input === "CANCEL" || input === "OK")) {
        this.updateInfoPaneWithMessage();
        return;
      }
      if (input === "CANCEL") {
        this.switchToMainBattleMenu();
        return;
      }
      if (input === "OK") {
        if (this.activeBattleMenu === ACTIVE_BATTLE_MENU.BATTLE_MAIN) {
          this.handlePlayerChooseMainBattleOption();
          return;
        }
        if (this.activeBattleMenu === ACTIVE_BATTLE_MENU.BATTLE_MOVE_SELECT) {
          this.handlePlayerChooseAttack();
          return;
        }
      }
      this.updateSelectedBattleMenuOptionFromInput(input);
      this.moveMainBattleMenuCursor();
      this.updateSelectedAttackMoveOptionFromInput(input);
      this.moveSubBattleMenuCursor();
    }
    updateInfoPaneMessagesAndWaitForInput(messages, callback, skipAnimation = false) {
      this.queuedInfoPanelMessages = messages;
      this.queuedInfoPanelCallback = callback;
      this.queuedMessagesSkipAnimation = skipAnimation;
      this.updateInfoPaneWithMessage();
    }
    updateInfoPaneMessagesNoInputRequired(message, callback, skipAnimation = false) {
      if (skipAnimation) {
        console.log("");
      }
      this.battleTextGameObjectLine1.setText("").setAlpha(1);
      this.battleTextGameObjectLine1.setText(message);
      this.waitingForPlayerInput = false;
      if (callback) {
        callback();
        return;
      }
      animateText(this.scene, this.battleTextGameObjectLine1, message, {
        callback: () => {
          this.waitingForPlayerInput = true;
        }
      });
    }
    updateInfoPaneWithMessage() {
      this.waitingForPlayerInput = false;
      this.battleTextGameObjectLine1.setText("").setAlpha(1);
      this.hideInputCursor();
      if (this.queuedInfoPanelMessages.length === 0) {
        if (this.queuedInfoPanelCallback) {
          this.queuedInfoPanelCallback();
          this.queuedInfoPanelCallback = void 0;
        }
        return;
      }
      const messageToDisplay = this.queuedInfoPanelMessages.shift() || [];
      if (this.queuedMessagesSkipAnimation) {
        this.battleTextGameObjectLine1.setText(messageToDisplay);
        this.queuedMessageAnimationPlaying = false;
        this.waitingForPlayerInput = true;
        this.playInputCursorAnimation();
        return;
      }
      this.queuedMessageAnimationPlaying = true;
      animateText(this.scene, this.battleTextGameObjectLine1, messageToDisplay, {
        callback: () => {
          this.playInputCursorAnimation();
          this.waitingForPlayerInput = true;
          this.queuedMessageAnimationPlaying = false;
        }
      });
    }
    createMainBattleMenu() {
      this.battleTextGameObjectLine1 = this.scene.add.text(20, 468, "What should", BATTLE_UI_TEXT_STYLE);
      this.battleTextGameObjectLine2 = this.scene.add.text(20, 512, `${this.activePlayerMonster.name} do next?`, BATTLE_UI_TEXT_STYLE);
      this.mainBattleMenuCursorPhaserImageGameObject = this.scene.add.image(BATTLE_MENU_CURSOR_POSITION.x, BATTLE_MENU_CURSOR_POSITION.y, UI_ASSET_KEYS.CURSOR, 0).setOrigin(0.5).setScale(1.5);
      this.mainBattleMenuPhaserContainerGameObject = this.scene.add.container(520, 448, [
        this.createSubInfoPane(),
        this.scene.add.text(55, 22, BATTLE_MENU_OPTIONS.FIGHT, BATTLE_UI_TEXT_STYLE),
        this.scene.add.text(240, 22, BATTLE_MENU_OPTIONS.SWITCH, BATTLE_UI_TEXT_STYLE),
        this.scene.add.text(55, 70, BATTLE_MENU_OPTIONS.ITEM, BATTLE_UI_TEXT_STYLE),
        this.scene.add.text(240, 70, BATTLE_MENU_OPTIONS.FLEE, BATTLE_UI_TEXT_STYLE),
        this.mainBattleMenuCursorPhaserImageGameObject
      ]);
    }
    createMonsterAttackSubMenu() {
      this.attackBattleMenuCursorPhaserImageGameObject = this.scene.add.image(42, 42, UI_ASSET_KEYS.CURSOR, 0).setOrigin(0.5).setScale(1.5);
      const attackNames = [];
      for (let i = 0; i < 4; i++) {
        attackNames.push(this.activePlayerMonster.attacks[i]?.name || "-");
      }
      this.moveSelectionSubMenuPhaserContainerGameObject = this.scene.add.container(0, 448, [
        this.scene.add.text(55, 22, attackNames[0], BATTLE_UI_TEXT_STYLE),
        this.scene.add.text(240, 22, attackNames[1], BATTLE_UI_TEXT_STYLE),
        this.scene.add.text(55, 70, attackNames[2], BATTLE_UI_TEXT_STYLE),
        this.scene.add.text(240, 70, attackNames[3], BATTLE_UI_TEXT_STYLE),
        this.attackBattleMenuCursorPhaserImageGameObject
      ]);
      this.hideMonsterAttackSubMenu();
    }
    createMainInfoPane() {
      const padding = 4;
      const rectangleHeight = 124;
      this.scene.add.rectangle(padding, this.scene.scale.height - rectangleHeight - padding, this.scene.scale.width - padding * 2, rectangleHeight, 15590643, 1).setOrigin(0).setStrokeStyle(8, 14959434, 1);
    }
    createSubInfoPane() {
      const rectangleWidth = 500;
      const rectangleHeight = 124;
      return this.scene.add.rectangle(0, 0, rectangleWidth, rectangleHeight, 15590643, 1).setOrigin(0).setStrokeStyle(8, 9460418, 1);
    }
    updateSelectedBattleMenuOptionFromInput(direction) {
      if (this.activeBattleMenu !== ACTIVE_BATTLE_MENU.BATTLE_MAIN) {
        return;
      }
      if (this.selectedBattleMenuOption === BATTLE_MENU_OPTIONS.FIGHT) {
        switch (direction) {
          case DIRECTION.RIGHT:
            this.selectedBattleMenuOption = BATTLE_MENU_OPTIONS.SWITCH;
            return;
          case DIRECTION.DOWN:
            this.selectedBattleMenuOption = BATTLE_MENU_OPTIONS.ITEM;
            return;
          case DIRECTION.LEFT:
            return;
          case DIRECTION.UP:
            return;
          case DIRECTION.NONE:
            return;
          default:
            exhaustiveGuard(direction);
        }
        return;
      }
      if (this.selectedBattleMenuOption === BATTLE_MENU_OPTIONS.SWITCH) {
        switch (direction) {
          case DIRECTION.DOWN:
            this.selectedBattleMenuOption = BATTLE_MENU_OPTIONS.FLEE;
            return;
          case DIRECTION.LEFT:
            this.selectedBattleMenuOption = BATTLE_MENU_OPTIONS.FIGHT;
            return;
          case DIRECTION.RIGHT:
            return;
          case DIRECTION.UP:
            return;
          case DIRECTION.NONE:
            return;
          default:
            exhaustiveGuard(direction);
        }
        return;
      }
      if (this.selectedBattleMenuOption === BATTLE_MENU_OPTIONS.ITEM) {
        switch (direction) {
          case DIRECTION.RIGHT:
            this.selectedBattleMenuOption = BATTLE_MENU_OPTIONS.FLEE;
            return;
          case DIRECTION.UP:
            this.selectedBattleMenuOption = BATTLE_MENU_OPTIONS.FIGHT;
            return;
          case DIRECTION.DOWN:
            return;
          case DIRECTION.LEFT:
            return;
          case DIRECTION.NONE:
            return;
          default:
            exhaustiveGuard(direction);
        }
        return;
      }
      if (this.selectedBattleMenuOption === BATTLE_MENU_OPTIONS.FLEE) {
        switch (direction) {
          case DIRECTION.LEFT:
            this.selectedBattleMenuOption = BATTLE_MENU_OPTIONS.ITEM;
            return;
          case DIRECTION.UP:
            this.selectedBattleMenuOption = BATTLE_MENU_OPTIONS.SWITCH;
            return;
          case DIRECTION.RIGHT:
            return;
          case DIRECTION.DOWN:
            return;
          case DIRECTION.NONE:
            return;
          default:
            exhaustiveGuard(direction);
        }
        return;
      }
      exhaustiveGuard(this.selectedBattleMenuOption);
    }
    moveMainBattleMenuCursor() {
      if (this.activeBattleMenu !== ACTIVE_BATTLE_MENU.BATTLE_MAIN) {
        return;
      }
      switch (this.selectedBattleMenuOption) {
        case BATTLE_MENU_OPTIONS.FIGHT:
          this.mainBattleMenuCursorPhaserImageGameObject.setPosition(BATTLE_MENU_CURSOR_POSITION.x, BATTLE_MENU_CURSOR_POSITION.y);
          return;
        case BATTLE_MENU_OPTIONS.SWITCH:
          this.mainBattleMenuCursorPhaserImageGameObject.setPosition(228, BATTLE_MENU_CURSOR_POSITION.y);
          return;
        case BATTLE_MENU_OPTIONS.ITEM:
          this.mainBattleMenuCursorPhaserImageGameObject.setPosition(BATTLE_MENU_CURSOR_POSITION.x, 90);
          return;
        case BATTLE_MENU_OPTIONS.FLEE:
          this.mainBattleMenuCursorPhaserImageGameObject.setPosition(228, 90);
          return;
        default:
          exhaustiveGuard(this.selectedBattleMenuOption);
      }
    }
    updateSelectedAttackMoveOptionFromInput(direction) {
      if (this.activeBattleMenu !== ACTIVE_BATTLE_MENU.BATTLE_MOVE_SELECT) {
        return;
      }
      if (this.selectedAttackMoveOption === ATTACK_MOVE_OPTIONS.MOVE_1) {
        switch (direction) {
          case DIRECTION.RIGHT:
            this.selectedAttackMoveOption = ATTACK_MOVE_OPTIONS.MOVE_2;
            return;
          case DIRECTION.DOWN:
            this.selectedAttackMoveOption = ATTACK_MOVE_OPTIONS.MOVE_3;
            return;
          case DIRECTION.LEFT:
            return;
          case DIRECTION.UP:
            return;
          case DIRECTION.NONE:
            return;
          default:
            exhaustiveGuard(direction);
        }
        return;
      }
      if (this.selectedAttackMoveOption === ATTACK_MOVE_OPTIONS.MOVE_2) {
        switch (direction) {
          case DIRECTION.LEFT:
            this.selectedAttackMoveOption = ATTACK_MOVE_OPTIONS.MOVE_1;
            return;
          case DIRECTION.DOWN:
            this.selectedAttackMoveOption = ATTACK_MOVE_OPTIONS.MOVE_4;
            return;
          case DIRECTION.RIGHT:
            return;
          case DIRECTION.UP:
            return;
          case DIRECTION.NONE:
            return;
          default:
            exhaustiveGuard(direction);
        }
        return;
      }
      if (this.selectedAttackMoveOption === ATTACK_MOVE_OPTIONS.MOVE_3) {
        switch (direction) {
          case DIRECTION.RIGHT:
            this.selectedAttackMoveOption = ATTACK_MOVE_OPTIONS.MOVE_4;
            return;
          case DIRECTION.UP:
            this.selectedAttackMoveOption = ATTACK_MOVE_OPTIONS.MOVE_1;
            return;
          case DIRECTION.LEFT:
            return;
          case DIRECTION.DOWN:
            return;
          case DIRECTION.NONE:
            return;
          default:
            exhaustiveGuard(direction);
        }
        return;
      }
      if (this.selectedAttackMoveOption === ATTACK_MOVE_OPTIONS.MOVE_4) {
        switch (direction) {
          case DIRECTION.LEFT:
            this.selectedAttackMoveOption = ATTACK_MOVE_OPTIONS.MOVE_3;
            return;
          case DIRECTION.UP:
            this.selectedAttackMoveOption = ATTACK_MOVE_OPTIONS.MOVE_2;
            return;
          case DIRECTION.RIGHT:
            return;
          case DIRECTION.DOWN:
            return;
          case DIRECTION.NONE:
            return;
          default:
            exhaustiveGuard(direction);
        }
      }
    }
    moveSubBattleMenuCursor() {
      if (this.activeBattleMenu !== ACTIVE_BATTLE_MENU.BATTLE_MOVE_SELECT) {
        return;
      }
      switch (this.selectedAttackMoveOption) {
        case ATTACK_MOVE_OPTIONS.MOVE_1:
          this.attackBattleMenuCursorPhaserImageGameObject.setPosition(ATTACK_MENU_CURSOR_POSITION.x, ATTACK_MENU_CURSOR_POSITION.y);
          return;
        case ATTACK_MOVE_OPTIONS.MOVE_2:
          this.attackBattleMenuCursorPhaserImageGameObject.setPosition(228, ATTACK_MENU_CURSOR_POSITION.y);
          return;
        case ATTACK_MOVE_OPTIONS.MOVE_3:
          this.attackBattleMenuCursorPhaserImageGameObject.setPosition(ATTACK_MENU_CURSOR_POSITION.x, 90);
          return;
        case ATTACK_MOVE_OPTIONS.MOVE_4:
          this.attackBattleMenuCursorPhaserImageGameObject.setPosition(228, 90);
          return;
        default:
          exhaustiveGuard(this.selectedAttackMoveOption);
      }
    }
    switchToMainBattleMenu() {
      this.waitingForPlayerInput = false;
      this.hideInputCursor();
      this.hideMonsterAttackSubMenu();
      this.showMainBattleMenu();
    }
    handlePlayerChooseMainBattleOption() {
      this.hideMainBattleMenu();
      if (this.selectedBattleMenuOption === BATTLE_MENU_OPTIONS.FIGHT) {
        this.showMonsterAttackSubMenu();
        this.activeBattleMenu = ACTIVE_BATTLE_MENU.BATTLE_MOVE_SELECT;
        return;
      }
      if (this.selectedBattleMenuOption === BATTLE_MENU_OPTIONS.SWITCH) {
        this.updateInfoPaneMessagesAndWaitForInput(["You have no other monsters..."], () => {
          this.switchToMainBattleMenu();
        }, SKIP_BATTLE_ANIMATIONS);
        this.activeBattleMenu = ACTIVE_BATTLE_MENU.BATTLE_SWITCH;
        return;
      }
      if (this.selectedBattleMenuOption === BATTLE_MENU_OPTIONS.ITEM) {
        this.updateInfoPaneMessagesAndWaitForInput(["Your bag is empty..."], () => {
          this.switchToMainBattleMenu();
        }, SKIP_BATTLE_ANIMATIONS);
        this.activeBattleMenu = ACTIVE_BATTLE_MENU.BATTLE_ITEM;
        return;
      }
      if (this.selectedBattleMenuOption === BATTLE_MENU_OPTIONS.FLEE) {
        this.updateInfoPaneMessagesAndWaitForInput(["You can't flee..."], () => {
          this.switchToMainBattleMenu();
        }, SKIP_BATTLE_ANIMATIONS);
        this.activeBattleMenu = ACTIVE_BATTLE_MENU.BATTLE_FLEE;
        return;
      }
      exhaustiveGuard(this.selectedBattleMenuOption);
    }
    handlePlayerChooseAttack() {
      let selectedAttackMoveIndex;
      switch (this.selectedAttackMoveOption) {
        case ATTACK_MOVE_OPTIONS.MOVE_1:
          selectedAttackMoveIndex = 0;
          break;
        case ATTACK_MOVE_OPTIONS.MOVE_2:
          selectedAttackMoveIndex = 1;
          break;
        case ATTACK_MOVE_OPTIONS.MOVE_3:
          selectedAttackMoveIndex = 2;
          break;
        case ATTACK_MOVE_OPTIONS.MOVE_4:
          selectedAttackMoveIndex = 3;
          break;
        default:
          exhaustiveGuard(this.selectedAttackMoveOption);
          selectedAttackMoveIndex = -1;
      }
      this.selectedAttackIndex = selectedAttackMoveIndex;
    }
    createPlayerInputCursor() {
      this.userInputCursorPhaserImageObject = this.scene.add.image(390, 0, UI_ASSET_KEYS.CURSOR).setAngle(90).setScale(2, 1.5).setAlpha(0);
      this.userInputCursorPhaserTween = this.scene.add.tween({
        delay: 0,
        duration: 800,
        repeat: -1,
        y: {
          from: PLAYER_INPUT_CURSOR_POSITION2.y + 7,
          start: PLAYER_INPUT_CURSOR_POSITION2.y + 7,
          to: PLAYER_INPUT_CURSOR_POSITION2.y + 12
        },
        targets: this.userInputCursorPhaserImageObject
      });
      this.userInputCursorPhaserTween.pause();
    }
  };

  // src/battle/background.ts
  var Background = class {
    scene;
    backgroundGameObject;
    constructor(scene) {
      this.scene = scene;
      this.backgroundGameObject = this.scene.add.image(0, 0, BATTLE_BACKGROUND_ASSET_KEYS.FOREST).setOrigin(0).setAlpha(0);
    }
    showForest() {
      this.backgroundGameObject.setTexture(BATTLE_BACKGROUND_ASSET_KEYS.FOREST).setAlpha(1);
    }
  };

  // src/battle/ui/health-bar.ts
  var HealthBar = class {
    scene;
    healthBarContainer;
    fullWidth;
    scaleY;
    leftCap;
    middle;
    rightCap;
    leftShadowCap;
    middleShadow;
    rightShadowCap;
    constructor(scene, x, y) {
      this.scene = scene;
      this.fullWidth = 360;
      this.scaleY = 0.7;
      this.healthBarContainer = this.scene.add.container(x, y, []);
      this.createHealthBarShadowImages(x, y);
      this.createHealthBarImages(x, y);
      this.setMeterPercentage(1);
    }
    get container() {
      return this.healthBarContainer;
    }
    createHealthBarShadowImages(x, y) {
      this.leftShadowCap = this.scene.add.image(x, y, HEALTH_BAR_ASSET_KEYS.LEFT_CAP_SHADOW).setOrigin(0, 0.5).setScale(1, this.scaleY);
      this.middleShadow = this.scene.add.image(this.leftShadowCap.x + this.leftShadowCap.width, y, HEALTH_BAR_ASSET_KEYS.MIDDLE_SHADOW).setOrigin(0, 0.5).setScale(1, this.scaleY);
      this.middleShadow.displayWidth = this.fullWidth;
      this.rightShadowCap = this.scene.add.image(this.middleShadow.x + this.middleShadow.displayWidth, y, HEALTH_BAR_ASSET_KEYS.RIGHT_CAP_SHADOW).setOrigin(0, 0.5).setScale(1, this.scaleY);
      this.healthBarContainer.add([this.leftShadowCap, this.middleShadow, this.rightShadowCap]);
    }
    createHealthBarImages(x, y) {
      this.leftCap = this.scene.add.image(x, y, HEALTH_BAR_ASSET_KEYS.LEFT_CAP).setOrigin(0, 0.5).setScale(1, this.scaleY);
      this.middle = this.scene.add.image(this.leftCap.x + this.leftCap.width, y, HEALTH_BAR_ASSET_KEYS.MIDDLE).setOrigin(0, 0.5).setScale(1, this.scaleY);
      this.rightCap = this.scene.add.image(this.middle.x + this.middle.displayWidth, y, HEALTH_BAR_ASSET_KEYS.RIGHT_CAP).setOrigin(0, 0.5).setScale(1, this.scaleY);
      this.healthBarContainer.add([this.leftCap, this.middle, this.rightCap]);
    }
    setMeterPercentage(percent = 1) {
      this.middle.displayWidth = this.fullWidth * percent;
      this.rightCap.x = this.middle.x + this.middle.displayWidth;
    }
    setMeterPercentageAnimated(percent = 1, options) {
      const width = this.fullWidth * percent;
      this.scene.tweens.add({
        targets: this.middle,
        displayWidth: width,
        duration: options?.duration ?? 1e3,
        ease: phaser_default.Math.Easing.Sine.Out,
        onUpdate: () => {
          this.rightCap.x = this.middle.x + this.middle.displayWidth;
          const isVisible = this.middle.displayWidth > 0;
          this.leftCap.visible = isVisible;
          this.rightCap.visible = isVisible;
        },
        onComplete: options?.callback
      });
    }
  };

  // src/battle/monsters/battle-monster.ts
  var BattleMonster = class {
    scene;
    monsterDetails;
    healthBar;
    phaserGameObject;
    currentHealth;
    maxHealth;
    monsterAttacks;
    phaserHealthBarGameContainer;
    skipBattleAnimations;
    constructor(config, position) {
      this.scene = config.scene;
      this.monsterDetails = config.monsterDetails;
      this.currentHealth = this.monsterDetails.currentHp;
      this.maxHealth = this.monsterDetails.maxHp;
      this.monsterAttacks = [];
      this.skipBattleAnimations = config.skipBattleAnimations || false;
      this.phaserGameObject = this.scene.add.image(position.x, position.y, this.monsterDetails.assetKey, this.monsterDetails.assetFrame ?? 0).setAlpha(0);
      this.createHealthBarComponent(config.scaleHealthBarBackgroundImageByY);
      this.monsterDetails.attackIds.forEach((attackId) => {
        const monsterAttack = DataUtils.getMonsterAttack(this.scene, attackId);
        if (monsterAttack !== void 0) {
          this.monsterAttacks.push(monsterAttack);
        }
      });
    }
    get isFainted() {
      return this.currentHealth <= 0;
    }
    get name() {
      return this.monsterDetails.name;
    }
    get attacks() {
      return [...this.monsterAttacks];
    }
    get baseAttack() {
      return this.monsterDetails.baseAttack;
    }
    get level() {
      return this.monsterDetails.currentLevel;
    }
    takeDamage(damage, callback) {
      this.currentHealth -= damage;
      if (this.currentHealth < 0) {
        this.currentHealth = 0;
      }
      this.healthBar.setMeterPercentageAnimated(this.currentHealth / this.maxHealth, {callback});
    }
    playMonsterTakeDamageAnimation(callback) {
      if (this.skipBattleAnimations) {
        this.phaserGameObject.setAlpha(1);
        callback();
        return;
      }
      this.scene.tweens.add({
        delay: 0,
        duration: 150,
        targets: this.phaserGameObject,
        alpha: 0,
        repeat: 5,
        onComplete: () => {
          this.phaserGameObject.setAlpha(1);
          callback();
        }
      });
    }
    playMonsterDeathAnimation(callback) {
      console.log(callback);
      throw new Error("playMonsterDeathAnimation is not implemented.");
    }
    createHealthBarComponent(scaleHealthBarByBackgroundImageByY = 1) {
      this.healthBar = new HealthBar(this.scene, 34, 34);
      const monsterNameGameText = this.scene.add.text(30, 20, this.monsterDetails.name, {
        fontFamily: CUSTOM_FONTS.POKEROGUE,
        color: "#7E3D3F",
        fontSize: "32px"
      });
      const healthBarBackgroundImage = this.scene.add.image(0, 0, BATTLE_ASSET_KEYS.HEALTH_BAR_BACKGROUND).setOrigin(0).setScale(1, scaleHealthBarByBackgroundImageByY);
      const monsterHealthBarLevelText = this.scene.add.text(monsterNameGameText.width + 35, 23, `L${this.level}`, {
        fontFamily: CUSTOM_FONTS.POKEROGUE,
        color: "#ED474B",
        fontSize: "28px"
      });
      const monsterHpText = this.scene.add.text(30, 54, "HP", {
        fontFamily: CUSTOM_FONTS.POKEROGUE,
        color: "#FF6505",
        fontSize: "24px",
        fontStyle: "italic"
      });
      this.phaserHealthBarGameContainer = this.scene.add.container(0, 0, [
        healthBarBackgroundImage,
        monsterNameGameText,
        this.healthBar.container,
        monsterHealthBarLevelText,
        monsterHpText
      ]).setAlpha(0);
    }
  };

  // src/battle/monsters/enemy-battle-monster.ts
  var ENEMY_POSITION = Object.freeze({
    x: 769,
    y: 144
  });
  var EnemyBattleMonster = class extends BattleMonster {
    constructor(config) {
      super({...config, scaleHealthBarBackgroundImageByY: 0.8}, ENEMY_POSITION);
    }
    playMonsterAppearAnimation(callback) {
      const startXPosition = -100;
      const endXPosition = ENEMY_POSITION.x;
      this.phaserGameObject.setPosition(startXPosition, ENEMY_POSITION.y);
      this.phaserGameObject.setAlpha(1);
      if (this.skipBattleAnimations) {
        this.phaserGameObject.setX(endXPosition);
        callback();
        return;
      }
      this.scene.tweens.add({
        delay: 0,
        duration: 1e3,
        targets: this.phaserGameObject,
        x: endXPosition,
        onComplete: () => {
          callback();
        }
      });
    }
    playMonsterHealthBarAppearAnimation(callback) {
      const startXPosition = -600;
      const endXPosition = this.phaserHealthBarGameContainer.x;
      this.phaserHealthBarGameContainer.setPosition(startXPosition, this.phaserHealthBarGameContainer.y);
      this.phaserHealthBarGameContainer.setAlpha(1);
      if (this.skipBattleAnimations) {
        this.phaserHealthBarGameContainer.setX(endXPosition);
        callback();
        return;
      }
      this.scene.tweens.add({
        delay: 0,
        duration: 500,
        targets: this.phaserHealthBarGameContainer,
        x: endXPosition,
        onComplete: () => {
          callback();
        }
      });
    }
    playMonsterDeathAnimation(callback) {
      const endYPosition = this.phaserGameObject.y - 400;
      if (this.skipBattleAnimations) {
        this.phaserGameObject.setY(endYPosition);
        callback();
        return;
      }
      this.scene.tweens.add({
        delay: 0,
        duration: 1e3,
        targets: this.phaserGameObject,
        y: endYPosition,
        onComplete: () => {
          callback();
        }
      });
    }
  };

  // src/battle/monsters/player-battle-monster.ts
  var PLAYER_POSITION = Object.freeze({
    x: 256,
    y: 316
  });
  var PlayerBattleMonster = class extends BattleMonster {
    healthBarTextGameObject;
    constructor(config) {
      super(config, PLAYER_POSITION);
      this.phaserGameObject.setFlipX(true);
      this.phaserHealthBarGameContainer.setPosition(556, 318);
      this.addHealthBarComponent();
    }
    playMonsterAppearAnimation(callback) {
      const startXPosition = 1024;
      const endXPosition = PLAYER_POSITION.x;
      this.phaserGameObject.setPosition(startXPosition, PLAYER_POSITION.y);
      this.phaserGameObject.setAlpha(1);
      if (this.skipBattleAnimations) {
        this.phaserGameObject.setX(endXPosition);
        callback();
        return;
      }
      this.scene.tweens.add({
        delay: 0,
        duration: 1e3,
        targets: this.phaserGameObject,
        x: endXPosition,
        onComplete: () => {
          callback();
        }
      });
    }
    playMonsterHealthBarAppearAnimation(callback) {
      const startXPosition = 1024;
      const endXPosition = this.phaserHealthBarGameContainer.x;
      this.phaserHealthBarGameContainer.setPosition(startXPosition, this.phaserHealthBarGameContainer.y);
      this.phaserHealthBarGameContainer.setAlpha(1);
      if (this.skipBattleAnimations) {
        this.phaserHealthBarGameContainer.setX(endXPosition);
        callback();
        return;
      }
      this.scene.tweens.add({
        delay: 0,
        duration: 500,
        targets: this.phaserHealthBarGameContainer,
        x: endXPosition,
        onComplete: () => {
          callback();
        }
      });
    }
    playMonsterDeathAnimation(callback) {
      const endYPosition = this.phaserGameObject.y + 400;
      if (this.skipBattleAnimations) {
        this.phaserGameObject.setY(endYPosition);
        callback();
        return;
      }
      this.scene.tweens.add({
        delay: 0,
        duration: 1e3,
        targets: this.phaserGameObject,
        y: endYPosition,
        onComplete: () => {
          callback();
        }
      });
    }
    setHealthBarText() {
      this.healthBarTextGameObject.setText(`${this.currentHealth}/${this.maxHealth}`);
    }
    addHealthBarComponent() {
      this.healthBarTextGameObject = this.scene.add.text(443, 80, "", {
        fontFamily: CUSTOM_FONTS.POKEROGUE,
        color: "7E3D3F",
        fontSize: "16px"
      }).setOrigin(1, 0);
      this.setHealthBarText();
      this.phaserHealthBarGameContainer.add(this.healthBarTextGameObject);
    }
    takeDamage(damage, callback) {
      super.takeDamage(damage, callback);
      this.setHealthBarText();
    }
  };

  // src/utils/state-machine.ts
  var StateMachine = class {
    states;
    currentState;
    id;
    context;
    isChangingState;
    ChangingStateQueue;
    constructor(id, context) {
      this.id = id;
      this.context = context;
      this.isChangingState = false;
      this.ChangingStateQueue = [];
      this.currentState = void 0;
      this.states = new Map();
    }
    get currentStateName() {
      return this.currentState?.name;
    }
    update() {
      if (this.ChangingStateQueue.length > 0) {
        this.setState(this.ChangingStateQueue.shift());
      }
    }
    setState(name) {
      const methodName = "setState";
      if (!this.states.has(name)) {
        console.warn(`[${StateMachine.name}-${this.id}:${methodName}] tried to change to unknown state: ${name}`);
        return;
      }
      if (this.isCurrentState(name)) {
        return;
      }
      if (this.isChangingState) {
        this.ChangingStateQueue.push(name);
        return;
      }
      this.isChangingState = true;
      this.currentState = this.states.get(name);
      if (this.currentState) {
        this.currentState.onEnter?.();
      }
      this.isChangingState = false;
    }
    addState(state) {
      this.states.set(state.name, {
        name: state.name,
        onEnter: this.context ? state.onEnter?.bind(this.context) : state.onEnter
      });
    }
    isCurrentState(name) {
      if (!this.currentState) {
        return false;
      }
      return this.currentState.name === name;
    }
  };

  // src/battle/attacks/attack-keys.ts
  var ATTACK_KEYS = Object.freeze({
    ICE_SHARD: "ICE_SHARD",
    SLASH: "SLASH"
  });

  // src/battle/attacks/attack.ts
  var Attack = class {
    scene;
    position;
    isAnimationPlaying;
    attackGameObject;
    constructor(scene, position) {
      this.scene = scene;
      this.position = position;
      this.isAnimationPlaying = false;
      this.attackGameObject = void 0;
    }
    getGameObject() {
      return this.attackGameObject;
    }
    playAnimation(callback) {
      console.log(callback);
      throw new Error("Parent class can't have animations");
    }
  };

  // src/battle/attacks/ice-shard.ts
  var IceShard = class extends Attack {
    attackGameObject;
    constructor(scene, position) {
      super(scene, position);
      this.attackGameObject = this.scene.add.sprite(this.position.x, this.position.y, ATTACK_ASSET_KEYS.ICE_SHARD, 5).setOrigin(0.5).setScale(4).setAlpha(0);
    }
    playAnimation(callback) {
      if (this.isAnimationPlaying) {
        return;
      }
      this.isAnimationPlaying = true;
      this.attackGameObject.setAlpha(1);
      this.attackGameObject.play(ATTACK_ASSET_KEYS.ICE_SHARD_START);
      this.attackGameObject.once(Phaser.Animations.Events.ANIMATION_COMPLETE_KEY + ATTACK_ASSET_KEYS.ICE_SHARD_START, () => {
        this.attackGameObject.play(ATTACK_ASSET_KEYS.ICE_SHARD);
      });
      this.attackGameObject.once(Phaser.Animations.Events.ANIMATION_COMPLETE_KEY + ATTACK_ASSET_KEYS.ICE_SHARD, () => {
        this.isAnimationPlaying = false;
        this.attackGameObject.setAlpha(0).setFrame(0);
        if (callback) {
          callback();
        }
      });
    }
  };

  // src/battle/attacks/slash.ts
  var Slash = class extends Attack {
    attackGameObject;
    attackGameObject1;
    attackGameObject2;
    attackGameObject3;
    constructor(scene, position) {
      super(scene, position);
      this.attackGameObject1 = this.scene.add.sprite(0, 0, ATTACK_ASSET_KEYS.SLASH, 0).setOrigin(0.5).setScale(4);
      this.attackGameObject2 = this.scene.add.sprite(30, 0, ATTACK_ASSET_KEYS.SLASH, 0).setOrigin(0.5).setScale(4);
      this.attackGameObject3 = this.scene.add.sprite(-30, 0, ATTACK_ASSET_KEYS.SLASH, 0).setOrigin(0.5).setScale(4);
      this.attackGameObject = this.scene.add.container(this.position.x, this.position.y, [
        this.attackGameObject1,
        this.attackGameObject2,
        this.attackGameObject3
      ]).setAlpha(0);
    }
    playAnimation(callback) {
      if (this.isAnimationPlaying) {
        return;
      }
      this.isAnimationPlaying = true;
      this.attackGameObject.setAlpha(1);
      this.attackGameObject1.play(ATTACK_ASSET_KEYS.SLASH);
      this.attackGameObject2.play(ATTACK_ASSET_KEYS.SLASH);
      this.attackGameObject3.play(ATTACK_ASSET_KEYS.SLASH);
      this.attackGameObject1.once(Phaser.Animations.Events.ANIMATION_COMPLETE_KEY + ATTACK_ASSET_KEYS.SLASH, () => {
        this.isAnimationPlaying = false;
        this.attackGameObject.setAlpha(0);
        this.attackGameObject1.setFrame(0);
        this.attackGameObject2.setFrame(0);
        this.attackGameObject3.setFrame(0);
        callback?.();
      });
    }
  };

  // src/battle/attacks/attack-manager.ts
  var ATTACK_TARGET = Object.freeze({
    PLAYER: "PLAYER",
    ENEMY: "ENEMY"
  });
  var AttackManager = class {
    scene;
    skipBattleAnimations;
    iceShardAttack;
    slashAttack;
    constructor(scene, skipBattleAnimations) {
      this.scene = scene;
      this.skipBattleAnimations = skipBattleAnimations;
    }
    playAttackAnimation(attack, target, callback) {
      if (this.skipBattleAnimations) {
        callback();
        return;
      }
      let x = 745;
      let y = 140;
      if (target === ATTACK_TARGET.PLAYER) {
        x = 256;
        y = 344;
      }
      switch (attack) {
        case ATTACK_KEYS.ICE_SHARD:
          if (!this.iceShardAttack) {
            this.iceShardAttack = new IceShard(this.scene, {x, y});
          }
          this.iceShardAttack.getGameObject()?.setPosition(x, y);
          this.iceShardAttack.playAnimation(callback);
          break;
        case ATTACK_KEYS.SLASH:
          if (!this.slashAttack) {
            this.slashAttack = new Slash(this.scene, {x, y});
          }
          this.slashAttack.getGameObject()?.setPosition(x, y);
          this.slashAttack.playAnimation(callback);
          break;
        default:
          exhaustiveGuard(attack);
      }
    }
  };

  // src/utils/scene-transition.ts
  function sceneTransition(scene, options) {
    const skipSceneTransition = options.skipSceneTransition || false;
    if (skipSceneTransition) {
      options.callback?.();
      return;
    }
    const {width, height} = scene.scale;
    const rectShape = new Phaser.Geom.Rectangle(0, height / 2, width, 0);
    const g = scene.add.graphics().fillRectShape(rectShape).setDepth(-1);
    const mask = g.createGeometryMask();
    scene.cameras.main.setMask(mask);
    scene.tweens.add({
      onUpdate: () => {
        g.clear().fillRectShape(rectShape);
      },
      delay: 400,
      duration: 800,
      height: {
        ease: Phaser.Math.Easing.Expo.InOut,
        from: 0,
        start: 0,
        to: height
      },
      y: {
        ease: Phaser.Math.Easing.Expo.InOut,
        from: height / 2,
        start: height / 2,
        to: 0
      },
      targets: rectShape,
      onComplete: () => {
        mask.destroy();
        scene.cameras.main.clearMask();
        options.callback?.();
      }
    });
    options.callback?.();
  }

  // src/lib/scenes/battle-scene.ts
  var BATTLE_STATES = Object.freeze({
    INTRO: "INTRO",
    PRE_BATTLE_INFO: "PRE_BATTLE_INFO",
    BRING_OUT_MONSTER: "BRING_OUT_MONSTER",
    PLAYER_INPUT: "PLAYER_INPUT",
    ENEMY_INPUT: "ENEMY_INPUT",
    BATTLE: "BATTLE",
    POST_ATTACK_CHECK: "POST_ATTACK_CHECK",
    FINISHED: "FINISHED",
    FLEE_ATTEMPT: "FLEE_ATTEMPT"
  });
  var BattleScene = class extends phaser_default.Scene {
    battleMenu;
    activeEnemyMonster;
    activePlayerMonster;
    activePlayerAttackIndex;
    battleStateMachine;
    attackManager;
    controls;
    constructor() {
      super({
        key: SCENE_KEYS.BATTLE_SCENE
      });
    }
    init() {
      this.activePlayerAttackIndex = -1;
    }
    create() {
      const background = new Background(this);
      background.showForest();
      this.activeEnemyMonster = new EnemyBattleMonster({
        scene: this,
        monsterDetails: {
          name: MONSTER_ASSET_KEYS.CARNODUSK,
          assetKey: MONSTER_ASSET_KEYS.CARNODUSK,
          assetFrame: 0,
          currentLevel: 5,
          currentHp: 25,
          maxHp: 25,
          attackIds: [1, 2],
          baseAttack: 25
        },
        skipBattleAnimations: SKIP_BATTLE_ANIMATIONS
      });
      this.activePlayerMonster = new PlayerBattleMonster({
        scene: this,
        monsterDetails: {
          name: MONSTER_ASSET_KEYS.IGUANIGNITE,
          assetKey: MONSTER_ASSET_KEYS.IGUANIGNITE,
          assetFrame: 0,
          currentLevel: 5,
          currentHp: 25,
          maxHp: 25,
          attackIds: [1, 2],
          baseAttack: 15
        },
        skipBattleAnimations: SKIP_BATTLE_ANIMATIONS
      });
      this.battleMenu = new BattleMenu(this, this.activePlayerMonster);
      this.createBattleStateMachine();
      this.attackManager = new AttackManager(this, SKIP_BATTLE_ANIMATIONS);
      this.controls = new Controls(this);
    }
    update() {
      this.battleStateMachine.update();
      const wasSpaceKeyPressed = this.controls.wasSpaceKeyPressed();
      if (wasSpaceKeyPressed && (this.battleStateMachine.currentStateName === BATTLE_STATES.PRE_BATTLE_INFO || this.battleStateMachine.currentStateName === BATTLE_STATES.POST_ATTACK_CHECK || this.battleStateMachine.currentStateName === BATTLE_STATES.BRING_OUT_MONSTER || this.battleStateMachine.currentStateName === BATTLE_STATES.FLEE_ATTEMPT)) {
        this.battleMenu.handlePlayerInput("OK");
        return;
      }
      if (this.battleStateMachine.currentStateName !== BATTLE_STATES.PLAYER_INPUT) {
        return;
      }
      if (wasSpaceKeyPressed) {
        this.battleMenu.handlePlayerInput("OK");
        if (this.battleMenu.selectedAttack === void 0) {
          return;
        }
        this.activePlayerAttackIndex = this.battleMenu.selectedAttack;
        if (!this.activePlayerMonster.attacks[this.activePlayerAttackIndex]) {
          return;
        }
        this.battleMenu.hideMonsterAttackSubMenu();
        this.battleStateMachine.setState(BATTLE_STATES.ENEMY_INPUT);
      }
      if (this.controls.wasBackKeyPressed()) {
        this.battleMenu.handlePlayerInput("CANCEL");
        return;
      }
      let selectedDirection = this.controls.getDirectionKeyPressedDown();
      if (selectedDirection !== DIRECTION.NONE) {
        this.battleMenu.handlePlayerInput(selectedDirection);
      }
    }
    playerAttack() {
      if (this.activePlayerMonster.isFainted) {
        return;
      }
      this.battleMenu.updateInfoPaneMessagesNoInputRequired(`${this.activePlayerMonster.name} used ${this.activePlayerMonster.attacks[this.activePlayerAttackIndex].name}`, () => {
        this.time.delayedCall(1200, () => {
          this.attackManager.playAttackAnimation(this.activePlayerMonster.attacks[this.activePlayerAttackIndex].animationName, ATTACK_TARGET.ENEMY, () => {
            this.activeEnemyMonster.playMonsterTakeDamageAnimation(() => {
              this.activeEnemyMonster.takeDamage(this.activePlayerMonster.baseAttack, () => {
                this.enemyAttack();
              });
            });
          });
        });
      }, SKIP_BATTLE_ANIMATIONS);
    }
    enemyAttack() {
      if (this.activeEnemyMonster.isFainted) {
        this.battleStateMachine.setState(BATTLE_STATES.POST_ATTACK_CHECK);
        return;
      }
      this.battleMenu.updateInfoPaneMessagesNoInputRequired(`${this.activeEnemyMonster.name} used ${this.activeEnemyMonster.attacks[0].name}`, () => {
        this.time.delayedCall(1200, () => {
          this.attackManager.playAttackAnimation(this.activeEnemyMonster.attacks[0].animationName, ATTACK_TARGET.PLAYER, () => {
            this.activePlayerMonster.playMonsterTakeDamageAnimation(() => {
              this.activePlayerMonster.takeDamage(this.activeEnemyMonster.baseAttack, () => {
                this.battleStateMachine.setState(BATTLE_STATES.POST_ATTACK_CHECK);
              });
            });
          });
        });
      }, SKIP_BATTLE_ANIMATIONS);
    }
    postBattleSequenceCheck() {
      if (this.activeEnemyMonster.isFainted) {
        this.battleMenu.updateInfoPaneMessagesAndWaitForInput([`Wild ${this.activeEnemyMonster.name} fucking died.`, `${this.activeEnemyMonster.name} gained experience`], () => {
          this.time.delayedCall(500, () => {
            this.activeEnemyMonster.playMonsterDeathAnimation(() => {
              this.battleStateMachine.setState(BATTLE_STATES.FINISHED);
            });
          });
        }, SKIP_BATTLE_ANIMATIONS);
        return;
      }
      if (this.activePlayerMonster.isFainted) {
        this.battleMenu.updateInfoPaneMessagesAndWaitForInput([`${this.activePlayerMonster.name} fainted`, "You have no more monsters, escaping to safety..."], () => {
          this.activePlayerMonster.playMonsterDeathAnimation(() => {
            this.time.delayedCall(500, () => {
              this.battleStateMachine.setState(BATTLE_STATES.FINISHED);
            });
          });
        }, SKIP_BATTLE_ANIMATIONS);
        return;
      }
      this.battleStateMachine.setState(BATTLE_STATES.PLAYER_INPUT);
    }
    transitionToNextScene() {
      this.cameras.main.fadeOut(600, 0, 0, 0);
      this.cameras.main.once(phaser_default.Cameras.Scene2D.Events.FADE_OUT_COMPLETE, () => {
        this.scene.start(SCENE_KEYS.BATTLE_SCENE);
      });
    }
    createBattleStateMachine() {
      this.battleStateMachine = new StateMachine("battle", this);
      this.battleStateMachine.addState({
        name: BATTLE_STATES.INTRO,
        onEnter: () => {
          sceneTransition(this, {
            skipSceneTransition: SKIP_BATTLE_ANIMATIONS,
            callback: () => {
              this.battleStateMachine.setState(BATTLE_STATES.PRE_BATTLE_INFO);
            }
          });
        }
      });
      this.battleStateMachine.addState({
        name: BATTLE_STATES.PRE_BATTLE_INFO,
        onEnter: () => {
          this.activeEnemyMonster.playMonsterAppearAnimation(() => {
            this.activeEnemyMonster.playMonsterHealthBarAppearAnimation(() => void 0);
            this.battleMenu.updateInfoPaneMessagesAndWaitForInput([`Wild ${this.activeEnemyMonster.name} appeared`], () => {
              this.time.delayedCall(500, () => {
                this.battleStateMachine.setState(BATTLE_STATES.BRING_OUT_MONSTER);
              });
            }, SKIP_BATTLE_ANIMATIONS);
          });
        }
      });
      this.battleStateMachine.addState({
        name: BATTLE_STATES.BRING_OUT_MONSTER,
        onEnter: () => {
          this.battleMenu.updateInfoPaneMessagesAndWaitForInput([`Go ${this.activePlayerMonster.name}`], () => {
            this.time.delayedCall(500, () => {
              this.battleStateMachine.setState(BATTLE_STATES.PLAYER_INPUT);
            });
          }, SKIP_BATTLE_ANIMATIONS);
          this.activePlayerMonster.playMonsterAppearAnimation(() => {
            this.activePlayerMonster.playMonsterHealthBarAppearAnimation(() => void 0);
          });
        }
      });
      this.battleStateMachine.addState({
        name: BATTLE_STATES.PLAYER_INPUT,
        onEnter: () => {
          this.battleMenu.showMainBattleMenu();
        }
      });
      this.battleStateMachine.addState({
        name: BATTLE_STATES.ENEMY_INPUT,
        onEnter: () => {
          this.battleStateMachine.setState(BATTLE_STATES.BATTLE);
        }
      });
      this.battleStateMachine.addState({
        name: BATTLE_STATES.BATTLE,
        onEnter: () => {
          this.playerAttack();
        }
      });
      this.battleStateMachine.addState({
        name: BATTLE_STATES.POST_ATTACK_CHECK,
        onEnter: () => {
          this.postBattleSequenceCheck();
        }
      });
      this.battleStateMachine.addState({
        name: BATTLE_STATES.FINISHED,
        onEnter: () => {
          this.transitionToNextScene();
        }
      });
      this.battleStateMachine.addState({
        name: BATTLE_STATES.FLEE_ATTEMPT,
        onEnter: () => {
          this.battleMenu.updateInfoPaneMessagesAndWaitForInput(["You got away safely"], () => {
            this.battleStateMachine.setState(BATTLE_STATES.FINISHED);
          }, SKIP_BATTLE_ANIMATIONS);
        }
      });
      this.battleStateMachine.setState("INTRO");
    }
  };

  // src/main.ts
  var game = new phaser_default.Game({
    type: phaser_default.CANVAS,
    scale: {
      parent: "game-container",
      width: 1024,
      height: 576,
      mode: phaser_default.Scale.FIT,
      autoCenter: phaser_default.Scale.CENTER_BOTH
    },
    backgroundColor: "#000000"
  });
  game.scene.add(SCENE_KEYS.PRELOAD_SCENE, PreloadScene);
  game.scene.add(SCENE_KEYS.BATTLE_SCENE, TitleScene);
  game.scene.add(SCENE_KEYS.BATTLE_SCENE, BattleScene);
  game.scene.start(SCENE_KEYS.PRELOAD_SCENE);
})();
