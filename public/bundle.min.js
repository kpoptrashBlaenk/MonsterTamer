(() => {
  // src/lib/phaser.ts
  var phaser_default = window.Phaser;

  // src/lib/scenes/scene-keys.ts
  var SCENE_KEYS = Object.freeze({
    TEST_SCENE: "TEST_SCENE",
    PRELOAD_SCENE: "PRELOAD_SCENE",
    BATTLE_SCENE: "BATTLE_SCENE",
    TITLE_SCENE: "TITLE_SCENE",
    OPTIONS_SCENE: "OPTIONS_SCENE"
  });

  // src/assets/asset-keys.ts
  var BATTLE_BACKGROUND_ASSET_KEYS = Object.freeze({
    FOREST: "FOREST"
  });
  var MONSTER_ASSET_KEYS = Object.freeze({
    IGUANIGNITE: "IGUANIGNITE",
    CARNODUSK: "CARNODUSK"
  });
  var BATTLE_ASSET_KEYS = Object.freeze({
    HEALTH_BAR_BACKGROUND: "HEALTH_BAR_BACKGROUND"
  });
  var HEALTH_BAR_ASSET_KEYS = Object.freeze({
    LEFT_CAP: "LEFT_CAP",
    RIGHT_CAP: "RIGHT_CAP",
    MIDDLE: "MIDDLE",
    LEFT_CAP_SHADOW: "LEFT_CAP_SHADOW",
    RIGHT_CAP_SHADOW: "RIGHT_CAP_SHADOW",
    MIDDLE_SHADOW: "MIDDLE_SHADOW"
  });
  var UI_ASSET_KEYS = Object.freeze({
    CURSOR: "CURSOR",
    CURSOR_WHITE: "CURSOR_WHITE",
    MENU_BACKGROUND: "MENU_BACKGROUND",
    MENU_BACKGROUND_GREEN: "MENU_BACKGROUND_GREEN",
    MENU_BACKGROUND_PURPLE: "MENU_BACKGROUND_PURPLE"
  });
  var DATA_ASSET_KEYS = Object.freeze({
    ATTACKS: "ATTACKS",
    ANIMATIONS: "ANIMATIONS"
  });
  var ATTACK_ASSET_KEYS = Object.freeze({
    ICE_SHARD: "ICE_SHARD",
    ICE_SHARD_START: "ICE_SHARD_START",
    SLASH: "SLASH"
  });
  var TITLE_ASSET_KEYS = Object.freeze({
    BACKGROUND: "BACKGROUND",
    TITLE: "TITLE",
    PANEL: "PANEL"
  });

  // src/assets/font-keys.ts
  var CUSTOM_FONTS = Object.freeze({
    KENNEY: "Kenney-Future-Narrow",
    POKEROGUE: "PokeRogue"
  });

  // src/lib/webfontloader.ts
  var webfontloader_default = window.WebFont;

  // src/assets/web-font-file-loader.ts
  var WebFontFileLoader = class extends phaser_default.Loader.File {
    fontNames;
    constructor(loader, fontNames) {
      super(loader, {
        type: "webfont",
        key: fontNames.toString()
      });
      this.fontNames = fontNames;
    }
    load() {
      webfontloader_default.load({
        custom: {
          families: this.fontNames
        },
        active: () => {
          this.loader.nextFile(this, true);
        },
        inactive: () => {
          console.error(`Failed to load custom fonts ${JSON.stringify(this.fontNames)}`);
          this.loader.nextFile(this, false);
        }
      });
    }
  };

  // src/utils/data-utils.ts
  var DataUtils = class {
    static getMonsterAttack(scene, attackId) {
      const data = scene.cache.json.get(DATA_ASSET_KEYS.ATTACKS);
      return data.find((attack) => attack.id === attackId);
    }
    static getAnimations(scene) {
      return scene.cache.json.get(DATA_ASSET_KEYS.ANIMATIONS);
    }
  };

  // src/common/options.ts
  var OPTION_MENU_OPTIONS = Object.freeze({
    TEXT_SPEED: "TEXT_SPEED",
    BATTLE_SCENE: "BATTLE_SCENE",
    SOUND: "SOUND",
    VOLUME: "VOLUME",
    MENU_COLOR: "MENU_COLOR",
    CLOSE: "CLOSE"
  });
  var TEXT_SPEED_OPTIONS = Object.freeze({
    SLOW: "SLOW",
    MID: "MID",
    FAST: "FAST"
  });
  var BATTLE_SCENE_OPTIONS = Object.freeze({
    ON: "ON",
    OFF: "OFF"
  });
  var SOUND_OPTIONS = Object.freeze({
    ON: "ON",
    OFF: "OFF"
  });

  // src/config.ts
  var TEXT_SPEED = Object.freeze({
    SLOW: 50,
    MID: 30,
    FAST: 15
  });

  // src/utils/guard.ts
  function exhaustiveGuard(_value) {
    throw new Error(`Error! Reached forbidden guard function with unexpected value: ${JSON.stringify(_value)}`);
  }

  // src/utils/data-manager.ts
  var LOCAL_STORAGE_KEY = "MONSTER_TAMER_DATA";
  var initialState = {
    options: {
      textSpeed: TEXT_SPEED_OPTIONS.SLOW,
      battleScene: BATTLE_SCENE_OPTIONS.ON,
      sound: SOUND_OPTIONS.ON,
      volume: 4,
      menuColor: 0
    }
  };
  var DATA_MANAGER_STORE_KEYS = Object.freeze({
    OPTIONS_TEXT_SPEED: "OPTIONS_TEXT_SPEED",
    OPTIONS_BATTLE_SCENE_ANIMATIONS: "OPTIONS_BATTLE_SCENE_ANIMATIONS",
    OPTIONS_SOUND: "OPTIONS_SOUND",
    OPTIONS_VOLUME: "OPTIONS_VOLUME",
    OPTIONS_MENU_COLOR: "OPTIONS_MENU_COLOR"
  });
  var DataManager = class extends phaser_default.Events.EventEmitter {
    store;
    constructor() {
      super();
      this.store = new phaser_default.Data.DataManager(this);
      this.updateDataManager(initialState);
    }
    get getStore() {
      return this.store;
    }
    loadData() {
      if (typeof Storage === "undefined") {
        console.warn(`[${DataManager.name}:loadData]: localStorage is not supported, can't save data.`);
        return;
      }
      const savedData = localStorage.getItem(LOCAL_STORAGE_KEY);
      if (savedData === null) {
        return;
      }
      try {
        const parsedData = JSON.parse(savedData);
        this.updateDataManager(parsedData);
      } catch (error) {
        console.warn(`[${DataManager.name}:saveData]: Error when trying to parse and save data from localStorage.`);
      }
    }
    saveData() {
      if (typeof Storage === "undefined") {
        console.warn(`[${DataManager.name}:saveData]: localStorage is not supported, can't save data.`);
        return;
      }
      const dataToSave = this.dataManagerDataToGlobalStateObject();
      localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(dataToSave));
    }
    getAnimatedTextSpeed() {
      const chosenTextSpeed = this.getStore.get(DATA_MANAGER_STORE_KEYS.OPTIONS_TEXT_SPEED);
      if (chosenTextSpeed === void 0) {
        return TEXT_SPEED.SLOW;
      }
      switch (chosenTextSpeed) {
        case TEXT_SPEED_OPTIONS.SLOW:
          return TEXT_SPEED.SLOW;
        case TEXT_SPEED_OPTIONS.MID:
          return TEXT_SPEED.MID;
        case TEXT_SPEED_OPTIONS.FAST:
          return TEXT_SPEED.FAST;
        default:
          exhaustiveGuard(chosenTextSpeed);
      }
    }
    dataManagerDataToGlobalStateObject() {
      return {
        options: {
          textSpeed: this.getStore.get(DATA_MANAGER_STORE_KEYS.OPTIONS_TEXT_SPEED),
          battleScene: this.getStore.get(DATA_MANAGER_STORE_KEYS.OPTIONS_BATTLE_SCENE_ANIMATIONS),
          sound: this.getStore.get(DATA_MANAGER_STORE_KEYS.OPTIONS_SOUND),
          volume: this.getStore.get(DATA_MANAGER_STORE_KEYS.OPTIONS_VOLUME),
          menuColor: this.getStore.get(DATA_MANAGER_STORE_KEYS.OPTIONS_MENU_COLOR)
        }
      };
    }
    updateDataManager(data) {
      this.store.set({
        [DATA_MANAGER_STORE_KEYS.OPTIONS_TEXT_SPEED]: data.options.textSpeed,
        [DATA_MANAGER_STORE_KEYS.OPTIONS_BATTLE_SCENE_ANIMATIONS]: data.options.battleScene,
        [DATA_MANAGER_STORE_KEYS.OPTIONS_SOUND]: data.options.sound,
        [DATA_MANAGER_STORE_KEYS.OPTIONS_VOLUME]: data.options.volume,
        [DATA_MANAGER_STORE_KEYS.OPTIONS_MENU_COLOR]: data.options.menuColor
      });
    }
  };
  var dataManager = new DataManager();

  // src/lib/scenes/preload-scene.ts
  var PreloadScene = class extends phaser_default.Scene {
    constructor() {
      super({
        key: SCENE_KEYS.PRELOAD_SCENE
      });
    }
    preload() {
      const monsterTamerAssetPath = "../assets/images/monster-tamer";
      const kenneysAssetPath = "../assets/images/kenneys-assets";
      const pimenAssetPath = "../assets/images/pimen";
      this.load.image(TITLE_ASSET_KEYS.BACKGROUND, `${monsterTamerAssetPath}/ui/title/background.png`);
      this.load.image(TITLE_ASSET_KEYS.PANEL, `${monsterTamerAssetPath}/ui/title/title_background.png`);
      this.load.image(TITLE_ASSET_KEYS.TITLE, `${monsterTamerAssetPath}/ui/title/title_text.png`);
      this.load.image(BATTLE_BACKGROUND_ASSET_KEYS.FOREST, `${monsterTamerAssetPath}/battle-backgrounds/forest-background.png`);
      this.load.image(BATTLE_ASSET_KEYS.HEALTH_BAR_BACKGROUND, `${kenneysAssetPath}/ui-space-expansion/custom-ui.png`);
      this.load.image(HEALTH_BAR_ASSET_KEYS.RIGHT_CAP, `${kenneysAssetPath}/ui-space-expansion/barHorizontal_green_right.png`);
      this.load.image(HEALTH_BAR_ASSET_KEYS.MIDDLE, `${kenneysAssetPath}/ui-space-expansion/barHorizontal_green_mid.png`);
      this.load.image(HEALTH_BAR_ASSET_KEYS.LEFT_CAP, `${kenneysAssetPath}/ui-space-expansion/barHorizontal_green_left.png`);
      this.load.image(HEALTH_BAR_ASSET_KEYS.RIGHT_CAP_SHADOW, `${kenneysAssetPath}/ui-space-expansion/barHorizontal_shadow_right.png`);
      this.load.image(HEALTH_BAR_ASSET_KEYS.MIDDLE_SHADOW, `${kenneysAssetPath}/ui-space-expansion/barHorizontal_shadow_mid.png`);
      this.load.image(HEALTH_BAR_ASSET_KEYS.LEFT_CAP_SHADOW, `${kenneysAssetPath}/ui-space-expansion/barHorizontal_shadow_left.png`);
      this.load.image(MONSTER_ASSET_KEYS.CARNODUSK, `${monsterTamerAssetPath}/monsters/carnodusk.png`);
      this.load.image(MONSTER_ASSET_KEYS.IGUANIGNITE, `${monsterTamerAssetPath}/monsters/iguanignite.png`);
      this.load.image(UI_ASSET_KEYS.CURSOR, `${monsterTamerAssetPath}/ui/cursor.png`);
      this.load.image(UI_ASSET_KEYS.CURSOR_WHITE, `${monsterTamerAssetPath}/ui/cursor_white.png`);
      this.load.image(UI_ASSET_KEYS.MENU_BACKGROUND, `${kenneysAssetPath}/ui-space-expansion/glassPanel.png`);
      this.load.image(UI_ASSET_KEYS.MENU_BACKGROUND_GREEN, `${kenneysAssetPath}/ui-space-expansion/glassPanel_green.png`);
      this.load.image(UI_ASSET_KEYS.MENU_BACKGROUND_PURPLE, `${kenneysAssetPath}/ui-space-expansion/glassPanel_purple.png`);
      this.load.json(DATA_ASSET_KEYS.ATTACKS, "assets/data/attacks.json");
      this.load.json(DATA_ASSET_KEYS.ANIMATIONS, "assets/data/animations.json");
      this.load.addFile(new WebFontFileLoader(this.load, [CUSTOM_FONTS.POKEROGUE]));
      this.load.spritesheet(ATTACK_ASSET_KEYS.ICE_SHARD, `${pimenAssetPath}/ice-attack/active.png`, {
        frameWidth: 32,
        frameHeight: 32
      });
      this.load.spritesheet(ATTACK_ASSET_KEYS.ICE_SHARD_START, `${pimenAssetPath}/ice-attack/start.png`, {
        frameWidth: 32,
        frameHeight: 32
      });
      this.load.spritesheet(ATTACK_ASSET_KEYS.SLASH, `${pimenAssetPath}/slash.png`, {frameWidth: 48, frameHeight: 48});
    }
    create() {
      this.createAnimations();
      dataManager.loadData();
      this.scene.start(SCENE_KEYS.TEST_SCENE);
    }
    createAnimations() {
      const animations = DataUtils.getAnimations(this);
      animations.forEach((animation) => {
        const frames = animation.frames ? this.anims.generateFrameNumbers(animation.assetKey, {frames: animation.frames}) : this.anims.generateFrameNumbers(animation.assetKey);
        this.anims.create({
          key: animation.key,
          frames,
          frameRate: animation.frameRate,
          repeat: animation.repeat,
          delay: animation.delay,
          yoyo: animation.yoyo
        });
      });
    }
  };

  // src/common/direction.ts
  var DIRECTION = Object.freeze({
    LEFT: "LEFT",
    RIGHT: "RIGHT",
    UP: "UP",
    DOWN: "DOWN",
    NONE: "NONE"
  });

  // src/utils/controls.ts
  var Controls = class {
    scene;
    cursorKeys;
    lockPlayerInput;
    constructor(scene) {
      this.scene = scene;
      this.cursorKeys = this.scene.input.keyboard?.createCursorKeys();
      this.lockPlayerInput = false;
    }
    get isInputLocked() {
      return this.lockPlayerInput;
    }
    set lockInput(value) {
      this.lockPlayerInput = value;
    }
    wasSpaceKeyPressed() {
      if (this.cursorKeys === void 0) {
        return false;
      }
      return phaser_default.Input.Keyboard.JustDown(this.cursorKeys.space);
    }
    wasBackKeyPressed() {
      if (this.cursorKeys === void 0) {
        return false;
      }
      return phaser_default.Input.Keyboard.JustDown(this.cursorKeys.shift);
    }
    getDirectionKeyPressedDown() {
      if (this.cursorKeys === void 0) {
        return DIRECTION.NONE;
      }
      let selectedDirection = DIRECTION.NONE;
      if (this.cursorKeys.left.isDown) {
        selectedDirection = DIRECTION.LEFT;
      } else if (this.cursorKeys.right.isDown) {
        selectedDirection = DIRECTION.RIGHT;
      } else if (this.cursorKeys.up.isDown) {
        selectedDirection = DIRECTION.UP;
      } else if (this.cursorKeys.down.isDown) {
        selectedDirection = DIRECTION.DOWN;
      }
      return selectedDirection;
    }
    getDirectionKeyJustDown() {
      if (this.cursorKeys === void 0) {
        return DIRECTION.NONE;
      }
      let selectedDirection = DIRECTION.NONE;
      if (phaser_default.Input.Keyboard.JustDown(this.cursorKeys.left)) {
        selectedDirection = DIRECTION.LEFT;
      } else if (phaser_default.Input.Keyboard.JustDown(this.cursorKeys.right)) {
        selectedDirection = DIRECTION.RIGHT;
      } else if (phaser_default.Input.Keyboard.JustDown(this.cursorKeys.up)) {
        selectedDirection = DIRECTION.UP;
      } else if (phaser_default.Input.Keyboard.JustDown(this.cursorKeys.down)) {
        selectedDirection = DIRECTION.DOWN;
      }
      return selectedDirection;
    }
  };

  // src/utils/nine-slice.ts
  var ASSET_CUT_FRAMES = Object.freeze({
    TL: "TL",
    TM: "TM",
    TR: "TR",
    ML: "ML",
    MM: "MM",
    MR: "MR",
    BL: "BL",
    BM: "BM",
    BR: "BR"
  });
  var ASSET_CUT_FRAME_DATA_MANAGER_NAME = "assetCutFrame";
  var NineSlice = class {
    cornerCutSize;
    constructor(config) {
      this.cornerCutSize = config.cornerCutSize;
      config.assetKeys.forEach((assetKey) => {
        this.createNineSliceTextures(config.textureManager, assetKey);
      });
    }
    createNineSliceTextures(textureManager, assetKey) {
      const methodName = "createNineSliceTextures";
      const texture = textureManager.get(assetKey);
      if (texture.key === "__MISSING") {
        console.warn(`[${NineSlice.name}:${methodName}] the provided texture asset Key was not found`);
        return;
      }
      if (texture.getFrameNames(false).length !== 0) {
        return;
      }
      const baseFrame = texture.frames["__BASE"];
      texture.add(ASSET_CUT_FRAMES.TL, 0, 0, 0, this.cornerCutSize, this.cornerCutSize);
      texture.add(ASSET_CUT_FRAMES.TM, 0, this.cornerCutSize, 0, baseFrame.width - this.cornerCutSize * 2, this.cornerCutSize);
      texture.add(ASSET_CUT_FRAMES.TR, 0, baseFrame.width - this.cornerCutSize, 0, this.cornerCutSize, this.cornerCutSize);
      texture.add(ASSET_CUT_FRAMES.ML, 0, 0, this.cornerCutSize, this.cornerCutSize, baseFrame.height - this.cornerCutSize * 2);
      texture.add(ASSET_CUT_FRAMES.MM, 0, this.cornerCutSize, this.cornerCutSize, baseFrame.width - this.cornerCutSize * 2, baseFrame.height - this.cornerCutSize * 2);
      texture.add(ASSET_CUT_FRAMES.MR, 0, baseFrame.width - this.cornerCutSize, this.cornerCutSize, this.cornerCutSize, baseFrame.height - this.cornerCutSize * 2);
      texture.add(ASSET_CUT_FRAMES.BL, 0, 0, baseFrame.height - this.cornerCutSize, this.cornerCutSize, this.cornerCutSize);
      texture.add(ASSET_CUT_FRAMES.BM, 0, this.cornerCutSize, baseFrame.height - this.cornerCutSize, baseFrame.width - this.cornerCutSize * 2, this.cornerCutSize);
      texture.add(ASSET_CUT_FRAMES.BR, 0, baseFrame.width - this.cornerCutSize, baseFrame.height - this.cornerCutSize, this.cornerCutSize, this.cornerCutSize);
    }
    createNineSliceContainer(scene, targetWidth, targetHeight, assetKey) {
      const tl = scene.add.image(0, 0, assetKey, ASSET_CUT_FRAMES.TL).setOrigin(0);
      tl.setData(ASSET_CUT_FRAME_DATA_MANAGER_NAME, ASSET_CUT_FRAMES.TL);
      const tm = scene.add.image(tl.displayWidth, 0, assetKey, ASSET_CUT_FRAMES.TM).setOrigin(0);
      tm.displayWidth = targetWidth - this.cornerCutSize * 2;
      tm.setData(ASSET_CUT_FRAME_DATA_MANAGER_NAME, ASSET_CUT_FRAMES.TM);
      const tr = scene.add.image(tl.displayWidth + tm.displayWidth, 0, assetKey, ASSET_CUT_FRAMES.TR).setOrigin(0);
      tr.setData(ASSET_CUT_FRAME_DATA_MANAGER_NAME, ASSET_CUT_FRAMES.TR);
      const ml = scene.add.image(0, tl.displayHeight, assetKey, ASSET_CUT_FRAMES.ML).setOrigin(0);
      ml.displayHeight = targetHeight - this.cornerCutSize * 2;
      ml.setData(ASSET_CUT_FRAME_DATA_MANAGER_NAME, ASSET_CUT_FRAMES.ML);
      const mm = scene.add.image(ml.displayWidth, ml.y, assetKey, ASSET_CUT_FRAMES.MM).setOrigin(0);
      mm.displayHeight = targetHeight - this.cornerCutSize * 2;
      mm.displayWidth = targetWidth - this.cornerCutSize * 2;
      mm.setData(ASSET_CUT_FRAME_DATA_MANAGER_NAME, ASSET_CUT_FRAMES.MM);
      const mr = scene.add.image(ml.displayWidth + mm.displayWidth, ml.y, assetKey, ASSET_CUT_FRAMES.MR).setOrigin(0);
      mr.displayHeight = mm.displayHeight;
      mr.setData(ASSET_CUT_FRAME_DATA_MANAGER_NAME, ASSET_CUT_FRAMES.MR);
      const bl = scene.add.image(0, tl.displayHeight + ml.displayHeight, assetKey, ASSET_CUT_FRAMES.BL).setOrigin(0);
      bl.setData(ASSET_CUT_FRAME_DATA_MANAGER_NAME, ASSET_CUT_FRAMES.BL);
      const bm = scene.add.image(bl.displayWidth, bl.y, assetKey, ASSET_CUT_FRAMES.BM).setOrigin(0);
      bm.displayWidth = tm.displayWidth;
      bm.setData(ASSET_CUT_FRAME_DATA_MANAGER_NAME, ASSET_CUT_FRAMES.BM);
      const br = scene.add.image(bl.displayWidth + bm.displayWidth, bl.y, assetKey, ASSET_CUT_FRAMES.BR).setOrigin(0);
      br.setData(ASSET_CUT_FRAME_DATA_MANAGER_NAME, ASSET_CUT_FRAMES.BR);
      return scene.add.container(0, 0, [tl, tm, tr, ml, mm, mr, bl, bm, br]);
    }
    updateNineSliceContainerTexture(textureManager, container, assetKey) {
      const methodName = "updateNineSliceContainerTexture";
      const texture = textureManager.get(assetKey);
      if (texture.key === "__MISSING") {
        console.warn(`[${NineSlice.name}:${methodName}] the provided texture asset Key was not found`);
        return;
      }
      if (texture.getFrameNames(false).length === 0) {
        return;
      }
      container.each((gameObject) => {
        const phaserImageGameObject = gameObject;
        if (phaserImageGameObject.type !== "Image") {
          return;
        }
        const frameName = phaserImageGameObject.getData(ASSET_CUT_FRAME_DATA_MANAGER_NAME);
        if (frameName === void 0) {
          return;
        }
        phaserImageGameObject.setTexture(assetKey, phaserImageGameObject.getData(ASSET_CUT_FRAME_DATA_MANAGER_NAME));
      });
    }
  };

  // src/lib/scenes/title-scene.ts
  var MENU_TEXT_STYLE = Object.freeze({
    fontFamily: CUSTOM_FONTS.POKEROGUE,
    color: "4D4A49",
    fontSize: "35px"
  });
  var PLAYER_INPUT_CURSOR_POSITION = Object.freeze({
    x: 170,
    y: 41
  });
  var MAIN_MENU_OPTIONS = Object.freeze({
    NEW_GAME: "NEW_GAME",
    CONTINUE: "CONTINUE",
    OPTIONS: "OPTIONS"
  });
  var TitleScene = class extends phaser_default.Scene {
    mainMenuCursorPhaserImageGameObject;
    controls;
    selectedMenuOption;
    isContinueButtonEnabled;
    nineSliceMenu;
    constructor() {
      super({
        key: SCENE_KEYS.TITLE_SCENE
      });
    }
    init() {
      this.nineSliceMenu = new NineSlice({
        cornerCutSize: 32,
        textureManager: this.sys.textures,
        assetKeys: [UI_ASSET_KEYS.MENU_BACKGROUND]
      });
    }
    create() {
      this.selectedMenuOption = MAIN_MENU_OPTIONS.NEW_GAME;
      this.isContinueButtonEnabled = false;
      this.add.image(0, 0, TITLE_ASSET_KEYS.BACKGROUND).setOrigin(0).setScale(0.58);
      this.add.image(this.scale.width / 2, 150, TITLE_ASSET_KEYS.PANEL).setScale(0.25, 0.25).setAlpha(0.5);
      this.add.image(this.scale.width / 2, 150, TITLE_ASSET_KEYS.TITLE).setScale(0.55).setAlpha(0.5);
      const menuBgWidth = 500;
      const menuBgContainer = this.nineSliceMenu.createNineSliceContainer(this, menuBgWidth, 200, UI_ASSET_KEYS.MENU_BACKGROUND);
      const newGameText = this.add.text(menuBgWidth / 2, 40, "New Game", MENU_TEXT_STYLE).setOrigin(0.5);
      const continueText = this.add.text(menuBgWidth / 2, 90, "Continue", MENU_TEXT_STYLE).setOrigin(0.5);
      if (!this.isContinueButtonEnabled) {
        continueText.setAlpha(0.5);
      }
      const optionsText = this.add.text(menuBgWidth / 2, 140, "Options", MENU_TEXT_STYLE).setOrigin(0.5);
      const menuContainer = this.add.container(0, 0, [menuBgContainer, newGameText, continueText, optionsText]);
      menuContainer.setPosition(this.scale.width / 2 - menuBgWidth / 2, 300);
      this.mainMenuCursorPhaserImageGameObject = this.add.image(PLAYER_INPUT_CURSOR_POSITION.x, PLAYER_INPUT_CURSOR_POSITION.y, UI_ASSET_KEYS.CURSOR).setOrigin(0.5).setScale(2.5);
      menuContainer.add(this.mainMenuCursorPhaserImageGameObject);
      this.add.tween({
        delay: 0,
        duration: 500,
        repeat: -1,
        x: {
          from: PLAYER_INPUT_CURSOR_POSITION.x,
          start: PLAYER_INPUT_CURSOR_POSITION.x,
          to: PLAYER_INPUT_CURSOR_POSITION.x + 3
        },
        targets: this.mainMenuCursorPhaserImageGameObject
      });
      this.cameras.main.once(phaser_default.Cameras.Scene2D.Events.FADE_OUT_COMPLETE, () => {
        if (this.selectedMenuOption === MAIN_MENU_OPTIONS.NEW_GAME) {
          this.scene.start(SCENE_KEYS.BATTLE_SCENE);
          return;
        }
        if (this.selectedMenuOption === MAIN_MENU_OPTIONS.CONTINUE) {
          this.scene.start(SCENE_KEYS.BATTLE_SCENE);
          return;
        }
        if (this.selectedMenuOption === MAIN_MENU_OPTIONS.OPTIONS) {
          this.scene.start(SCENE_KEYS.OPTIONS_SCENE);
        }
      });
      this.controls = new Controls(this);
    }
    update() {
      if (this.controls.isInputLocked) {
        return;
      }
      const wasSpaceKeyPressed = this.controls.wasSpaceKeyPressed();
      if (wasSpaceKeyPressed) {
        this.cameras.main.fadeOut(500, 0, 0, 0);
        this.controls.lockInput = true;
        return;
      }
      let selectedDirection = this.controls.getDirectionKeyJustDown();
      if (selectedDirection !== DIRECTION.NONE) {
        this.moveMenuSelectCursor(selectedDirection);
      }
    }
    moveMenuSelectCursor(direction) {
      this.updateSelectedOptionFromInput(direction);
      switch (this.selectedMenuOption) {
        case MAIN_MENU_OPTIONS.NEW_GAME:
          this.mainMenuCursorPhaserImageGameObject.setY(PLAYER_INPUT_CURSOR_POSITION.y);
          break;
        case MAIN_MENU_OPTIONS.CONTINUE:
          this.mainMenuCursorPhaserImageGameObject.setY(91);
          break;
        case MAIN_MENU_OPTIONS.OPTIONS:
          this.mainMenuCursorPhaserImageGameObject.setY(141);
          break;
        default:
          exhaustiveGuard(this.selectedMenuOption);
      }
    }
    updateSelectedOptionFromInput(direction) {
      switch (direction) {
        case DIRECTION.UP:
          if (this.selectedMenuOption === MAIN_MENU_OPTIONS.NEW_GAME) {
            return;
          }
          if (this.selectedMenuOption === MAIN_MENU_OPTIONS.CONTINUE) {
            this.selectedMenuOption = MAIN_MENU_OPTIONS.NEW_GAME;
            return;
          }
          if (this.selectedMenuOption === MAIN_MENU_OPTIONS.OPTIONS && !this.isContinueButtonEnabled) {
            this.selectedMenuOption = MAIN_MENU_OPTIONS.NEW_GAME;
            return;
          }
          if (this.selectedMenuOption === MAIN_MENU_OPTIONS.OPTIONS) {
            this.selectedMenuOption = MAIN_MENU_OPTIONS.CONTINUE;
            return;
          }
          return;
        case DIRECTION.DOWN:
          if (this.selectedMenuOption === MAIN_MENU_OPTIONS.NEW_GAME && !this.isContinueButtonEnabled) {
            this.selectedMenuOption = MAIN_MENU_OPTIONS.OPTIONS;
            return;
          }
          if (this.selectedMenuOption === MAIN_MENU_OPTIONS.NEW_GAME) {
            this.selectedMenuOption = MAIN_MENU_OPTIONS.CONTINUE;
            return;
          }
          if (this.selectedMenuOption === MAIN_MENU_OPTIONS.CONTINUE) {
            this.selectedMenuOption = MAIN_MENU_OPTIONS.OPTIONS;
            return;
          }
          if (this.selectedMenuOption === MAIN_MENU_OPTIONS.OPTIONS) {
            return;
          }
          return;
        case DIRECTION.LEFT:
        case DIRECTION.RIGHT:
        case DIRECTION.NONE:
          return;
        default:
          exhaustiveGuard(direction);
      }
    }
  };

  // src/battle/ui/battle-menu-options.ts
  var BATTLE_MENU_OPTIONS = Object.freeze({
    FIGHT: "FIGHT",
    SWITCH: "SWITCH",
    ITEM: "ITEM",
    FLEE: "FLEE"
  });
  var ATTACK_MOVE_OPTIONS = Object.freeze({
    MOVE_1: "MOVE_1",
    MOVE_2: "MOVE_2",
    MOVE_3: "MOVE_3",
    MOVE_4: "MOVE_4"
  });
  var ACTIVE_BATTLE_MENU = Object.freeze({
    BATTLE_MAIN: "BATTLE_MAIN",
    BATTLE_MOVE_SELECT: "BATTLE_MOVE_SELECT",
    BATTLE_ITEM: "BATTLE_ITEM",
    BATTLE_SWITCH: "BATTLE_SWITCH",
    BATTLE_FLEE: "BATTLE_FLEE"
  });

  // src/battle/ui/battle-menu-config.ts
  var BATTLE_UI_TEXT_STYLE = Object.freeze({
    fontFamily: CUSTOM_FONTS.POKEROGUE,
    color: "black",
    fontSize: "35px"
  });

  // src/utils/text-utils.ts
  function animateText(scene, target, text, config) {
    const length = text.length;
    let i = 0;
    scene.time.addEvent({
      callback: () => {
        target.text += text[i];
        i++;
        if (i === length - 1 && config?.callback) {
          config.callback();
        }
      },
      repeat: length - 1,
      delay: config?.delay ?? 50
    });
  }

  // src/battle/menu/battle-menu.ts
  var BATTLE_MENU_CURSOR_POSITION = Object.freeze({
    x: 42,
    y: 42
  });
  var ATTACK_MENU_CURSOR_POSITION = Object.freeze({
    x: 42,
    y: 42
  });
  var PLAYER_INPUT_CURSOR_POSITION2 = Object.freeze({
    y: 480
  });
  var BattleMenu = class {
    scene;
    mainBattleMenuPhaserContainerGameObject;
    moveSelectionSubMenuPhaserContainerGameObject;
    battleTextGameObjectLine1;
    battleTextGameObjectLine2;
    mainBattleMenuCursorPhaserImageGameObject;
    attackBattleMenuCursorPhaserImageGameObject;
    selectedBattleMenuOption;
    selectedAttackMoveOption;
    activeBattleMenu;
    queuedInfoPanelMessages;
    queuedInfoPanelCallback;
    waitingForPlayerInput;
    selectedAttackIndex;
    activePlayerMonster;
    userInputCursorPhaserImageObject;
    userInputCursorPhaserTween;
    skipAnimations;
    queuedMessageAnimationPlaying;
    constructor(scene, activePlayerMonster, skipBattleAnimations = false) {
      this.scene = scene;
      this.activePlayerMonster = activePlayerMonster;
      this.activeBattleMenu = ACTIVE_BATTLE_MENU.BATTLE_MAIN;
      this.selectedBattleMenuOption = BATTLE_MENU_OPTIONS.FIGHT;
      this.selectedAttackMoveOption = ATTACK_MOVE_OPTIONS.MOVE_1;
      this.queuedInfoPanelCallback = void 0;
      this.queuedInfoPanelMessages = [];
      this.waitingForPlayerInput = false;
      this.selectedAttackIndex = void 0;
      this.skipAnimations = skipBattleAnimations;
      this.queuedMessageAnimationPlaying = false;
      this.createMainInfoPane();
      this.createMainBattleMenu();
      this.createMonsterAttackSubMenu();
      this.createPlayerInputCursor();
      this.hideMonsterAttackSubMenu();
      this.hideMainBattleMenu();
    }
    get selectedAttack() {
      if (this.activeBattleMenu === ACTIVE_BATTLE_MENU.BATTLE_MOVE_SELECT) {
        return this.selectedAttackIndex;
      }
      return void 0;
    }
    showMainBattleMenu() {
      this.activeBattleMenu = ACTIVE_BATTLE_MENU.BATTLE_MAIN;
      this.battleTextGameObjectLine1.setText("What should");
      this.mainBattleMenuPhaserContainerGameObject.setAlpha(1);
      this.battleTextGameObjectLine1.setAlpha(1);
      this.battleTextGameObjectLine2.setAlpha(1);
      this.selectedBattleMenuOption = BATTLE_MENU_OPTIONS.FIGHT;
      this.mainBattleMenuCursorPhaserImageGameObject.setPosition(BATTLE_MENU_CURSOR_POSITION.x, BATTLE_MENU_CURSOR_POSITION.y);
      this.selectedAttackIndex = void 0;
    }
    hideMainBattleMenu() {
      this.mainBattleMenuPhaserContainerGameObject.setAlpha(0);
      this.battleTextGameObjectLine1.setAlpha(0);
      this.battleTextGameObjectLine2.setAlpha(0);
    }
    showMonsterAttackSubMenu() {
      this.activeBattleMenu = ACTIVE_BATTLE_MENU.BATTLE_MOVE_SELECT;
      this.moveSelectionSubMenuPhaserContainerGameObject.setAlpha(1);
    }
    hideMonsterAttackSubMenu() {
      this.activeBattleMenu = ACTIVE_BATTLE_MENU.BATTLE_MAIN;
      this.moveSelectionSubMenuPhaserContainerGameObject.setAlpha(0);
    }
    playInputCursorAnimation() {
      this.userInputCursorPhaserImageObject.setPosition(this.battleTextGameObjectLine1.displayWidth + this.userInputCursorPhaserImageObject.displayWidth * 3.5, this.userInputCursorPhaserImageObject.y).setAlpha(1);
      this.userInputCursorPhaserTween.restart();
    }
    hideInputCursor() {
      this.userInputCursorPhaserImageObject.setAlpha(0);
      this.userInputCursorPhaserTween.pause();
    }
    handlePlayerInput(input) {
      if (this.queuedMessageAnimationPlaying && input === "OK") {
        return;
      }
      if (this.waitingForPlayerInput && (input === "CANCEL" || input === "OK")) {
        this.updateInfoPaneWithMessage();
        return;
      }
      if (input === "CANCEL") {
        this.switchToMainBattleMenu();
        return;
      }
      if (input === "OK") {
        if (this.activeBattleMenu === ACTIVE_BATTLE_MENU.BATTLE_MAIN) {
          this.handlePlayerChooseMainBattleOption();
          return;
        }
        if (this.activeBattleMenu === ACTIVE_BATTLE_MENU.BATTLE_MOVE_SELECT) {
          this.handlePlayerChooseAttack();
          return;
        }
      }
      this.updateSelectedBattleMenuOptionFromInput(input);
      this.moveMainBattleMenuCursor();
      this.updateSelectedAttackMoveOptionFromInput(input);
      this.moveSubBattleMenuCursor();
    }
    updateInfoPaneMessagesAndWaitForInput(messages, callback) {
      this.queuedInfoPanelMessages = messages;
      this.queuedInfoPanelCallback = callback;
      this.updateInfoPaneWithMessage();
    }
    updateInfoPaneMessagesNoInputRequired(message, callback) {
      if (this.skipAnimations) {
        console.log("");
      }
      this.battleTextGameObjectLine1.setText("").setAlpha(1);
      this.battleTextGameObjectLine1.setText(message);
      this.waitingForPlayerInput = false;
      if (callback) {
        callback();
        return;
      }
      animateText(this.scene, this.battleTextGameObjectLine1, message, {
        delay: dataManager.getAnimatedTextSpeed(),
        callback: () => {
          this.waitingForPlayerInput = true;
        }
      });
    }
    updateInfoPaneWithMessage() {
      this.waitingForPlayerInput = false;
      this.battleTextGameObjectLine1.setText("").setAlpha(1);
      this.hideInputCursor();
      if (this.queuedInfoPanelMessages.length === 0) {
        if (this.queuedInfoPanelCallback) {
          this.queuedInfoPanelCallback();
          this.queuedInfoPanelCallback = void 0;
        }
        return;
      }
      const messageToDisplay = this.queuedInfoPanelMessages.shift() || [];
      if (this.skipAnimations) {
        this.battleTextGameObjectLine1.setText(messageToDisplay);
        this.queuedMessageAnimationPlaying = false;
        this.waitingForPlayerInput = true;
        this.playInputCursorAnimation();
        return;
      }
      this.queuedMessageAnimationPlaying = true;
      animateText(this.scene, this.battleTextGameObjectLine1, messageToDisplay, {
        delay: dataManager.getAnimatedTextSpeed(),
        callback: () => {
          this.playInputCursorAnimation();
          this.waitingForPlayerInput = true;
          this.queuedMessageAnimationPlaying = false;
        }
      });
    }
    createMainBattleMenu() {
      this.battleTextGameObjectLine1 = this.scene.add.text(20, 468, "What should", BATTLE_UI_TEXT_STYLE);
      this.battleTextGameObjectLine2 = this.scene.add.text(20, 512, `${this.activePlayerMonster.name} do next?`, BATTLE_UI_TEXT_STYLE);
      this.mainBattleMenuCursorPhaserImageGameObject = this.scene.add.image(BATTLE_MENU_CURSOR_POSITION.x, BATTLE_MENU_CURSOR_POSITION.y, UI_ASSET_KEYS.CURSOR, 0).setOrigin(0.5).setScale(1.5);
      this.mainBattleMenuPhaserContainerGameObject = this.scene.add.container(520, 448, [
        this.createSubInfoPane(),
        this.scene.add.text(55, 22, BATTLE_MENU_OPTIONS.FIGHT, BATTLE_UI_TEXT_STYLE),
        this.scene.add.text(240, 22, BATTLE_MENU_OPTIONS.SWITCH, BATTLE_UI_TEXT_STYLE),
        this.scene.add.text(55, 70, BATTLE_MENU_OPTIONS.ITEM, BATTLE_UI_TEXT_STYLE),
        this.scene.add.text(240, 70, BATTLE_MENU_OPTIONS.FLEE, BATTLE_UI_TEXT_STYLE),
        this.mainBattleMenuCursorPhaserImageGameObject
      ]);
    }
    createMonsterAttackSubMenu() {
      this.attackBattleMenuCursorPhaserImageGameObject = this.scene.add.image(42, 42, UI_ASSET_KEYS.CURSOR, 0).setOrigin(0.5).setScale(1.5);
      const attackNames = [];
      for (let i = 0; i < 4; i++) {
        attackNames.push(this.activePlayerMonster.attacks[i]?.name || "-");
      }
      this.moveSelectionSubMenuPhaserContainerGameObject = this.scene.add.container(0, 448, [
        this.scene.add.text(55, 22, attackNames[0], BATTLE_UI_TEXT_STYLE),
        this.scene.add.text(240, 22, attackNames[1], BATTLE_UI_TEXT_STYLE),
        this.scene.add.text(55, 70, attackNames[2], BATTLE_UI_TEXT_STYLE),
        this.scene.add.text(240, 70, attackNames[3], BATTLE_UI_TEXT_STYLE),
        this.attackBattleMenuCursorPhaserImageGameObject
      ]);
      this.hideMonsterAttackSubMenu();
    }
    createMainInfoPane() {
      const padding = 4;
      const rectangleHeight = 124;
      this.scene.add.rectangle(padding, this.scene.scale.height - rectangleHeight - padding, this.scene.scale.width - padding * 2, rectangleHeight, 15590643, 1).setOrigin(0).setStrokeStyle(8, 14959434, 1);
    }
    createSubInfoPane() {
      const rectangleWidth = 500;
      const rectangleHeight = 124;
      return this.scene.add.rectangle(0, 0, rectangleWidth, rectangleHeight, 15590643, 1).setOrigin(0).setStrokeStyle(8, 9460418, 1);
    }
    updateSelectedBattleMenuOptionFromInput(direction) {
      if (this.activeBattleMenu !== ACTIVE_BATTLE_MENU.BATTLE_MAIN) {
        return;
      }
      if (this.selectedBattleMenuOption === BATTLE_MENU_OPTIONS.FIGHT) {
        switch (direction) {
          case DIRECTION.RIGHT:
            this.selectedBattleMenuOption = BATTLE_MENU_OPTIONS.SWITCH;
            return;
          case DIRECTION.DOWN:
            this.selectedBattleMenuOption = BATTLE_MENU_OPTIONS.ITEM;
            return;
          case DIRECTION.LEFT:
            return;
          case DIRECTION.UP:
            return;
          case DIRECTION.NONE:
            return;
          default:
            exhaustiveGuard(direction);
        }
        return;
      }
      if (this.selectedBattleMenuOption === BATTLE_MENU_OPTIONS.SWITCH) {
        switch (direction) {
          case DIRECTION.DOWN:
            this.selectedBattleMenuOption = BATTLE_MENU_OPTIONS.FLEE;
            return;
          case DIRECTION.LEFT:
            this.selectedBattleMenuOption = BATTLE_MENU_OPTIONS.FIGHT;
            return;
          case DIRECTION.RIGHT:
            return;
          case DIRECTION.UP:
            return;
          case DIRECTION.NONE:
            return;
          default:
            exhaustiveGuard(direction);
        }
        return;
      }
      if (this.selectedBattleMenuOption === BATTLE_MENU_OPTIONS.ITEM) {
        switch (direction) {
          case DIRECTION.RIGHT:
            this.selectedBattleMenuOption = BATTLE_MENU_OPTIONS.FLEE;
            return;
          case DIRECTION.UP:
            this.selectedBattleMenuOption = BATTLE_MENU_OPTIONS.FIGHT;
            return;
          case DIRECTION.DOWN:
            return;
          case DIRECTION.LEFT:
            return;
          case DIRECTION.NONE:
            return;
          default:
            exhaustiveGuard(direction);
        }
        return;
      }
      if (this.selectedBattleMenuOption === BATTLE_MENU_OPTIONS.FLEE) {
        switch (direction) {
          case DIRECTION.LEFT:
            this.selectedBattleMenuOption = BATTLE_MENU_OPTIONS.ITEM;
            return;
          case DIRECTION.UP:
            this.selectedBattleMenuOption = BATTLE_MENU_OPTIONS.SWITCH;
            return;
          case DIRECTION.RIGHT:
            return;
          case DIRECTION.DOWN:
            return;
          case DIRECTION.NONE:
            return;
          default:
            exhaustiveGuard(direction);
        }
        return;
      }
      exhaustiveGuard(this.selectedBattleMenuOption);
    }
    moveMainBattleMenuCursor() {
      if (this.activeBattleMenu !== ACTIVE_BATTLE_MENU.BATTLE_MAIN) {
        return;
      }
      switch (this.selectedBattleMenuOption) {
        case BATTLE_MENU_OPTIONS.FIGHT:
          this.mainBattleMenuCursorPhaserImageGameObject.setPosition(BATTLE_MENU_CURSOR_POSITION.x, BATTLE_MENU_CURSOR_POSITION.y);
          return;
        case BATTLE_MENU_OPTIONS.SWITCH:
          this.mainBattleMenuCursorPhaserImageGameObject.setPosition(228, BATTLE_MENU_CURSOR_POSITION.y);
          return;
        case BATTLE_MENU_OPTIONS.ITEM:
          this.mainBattleMenuCursorPhaserImageGameObject.setPosition(BATTLE_MENU_CURSOR_POSITION.x, 90);
          return;
        case BATTLE_MENU_OPTIONS.FLEE:
          this.mainBattleMenuCursorPhaserImageGameObject.setPosition(228, 90);
          return;
        default:
          exhaustiveGuard(this.selectedBattleMenuOption);
      }
    }
    updateSelectedAttackMoveOptionFromInput(direction) {
      if (this.activeBattleMenu !== ACTIVE_BATTLE_MENU.BATTLE_MOVE_SELECT) {
        return;
      }
      if (this.selectedAttackMoveOption === ATTACK_MOVE_OPTIONS.MOVE_1) {
        switch (direction) {
          case DIRECTION.RIGHT:
            this.selectedAttackMoveOption = ATTACK_MOVE_OPTIONS.MOVE_2;
            return;
          case DIRECTION.DOWN:
            this.selectedAttackMoveOption = ATTACK_MOVE_OPTIONS.MOVE_3;
            return;
          case DIRECTION.LEFT:
            return;
          case DIRECTION.UP:
            return;
          case DIRECTION.NONE:
            return;
          default:
            exhaustiveGuard(direction);
        }
        return;
      }
      if (this.selectedAttackMoveOption === ATTACK_MOVE_OPTIONS.MOVE_2) {
        switch (direction) {
          case DIRECTION.LEFT:
            this.selectedAttackMoveOption = ATTACK_MOVE_OPTIONS.MOVE_1;
            return;
          case DIRECTION.DOWN:
            this.selectedAttackMoveOption = ATTACK_MOVE_OPTIONS.MOVE_4;
            return;
          case DIRECTION.RIGHT:
            return;
          case DIRECTION.UP:
            return;
          case DIRECTION.NONE:
            return;
          default:
            exhaustiveGuard(direction);
        }
        return;
      }
      if (this.selectedAttackMoveOption === ATTACK_MOVE_OPTIONS.MOVE_3) {
        switch (direction) {
          case DIRECTION.RIGHT:
            this.selectedAttackMoveOption = ATTACK_MOVE_OPTIONS.MOVE_4;
            return;
          case DIRECTION.UP:
            this.selectedAttackMoveOption = ATTACK_MOVE_OPTIONS.MOVE_1;
            return;
          case DIRECTION.LEFT:
            return;
          case DIRECTION.DOWN:
            return;
          case DIRECTION.NONE:
            return;
          default:
            exhaustiveGuard(direction);
        }
        return;
      }
      if (this.selectedAttackMoveOption === ATTACK_MOVE_OPTIONS.MOVE_4) {
        switch (direction) {
          case DIRECTION.LEFT:
            this.selectedAttackMoveOption = ATTACK_MOVE_OPTIONS.MOVE_3;
            return;
          case DIRECTION.UP:
            this.selectedAttackMoveOption = ATTACK_MOVE_OPTIONS.MOVE_2;
            return;
          case DIRECTION.RIGHT:
            return;
          case DIRECTION.DOWN:
            return;
          case DIRECTION.NONE:
            return;
          default:
            exhaustiveGuard(direction);
        }
      }
    }
    moveSubBattleMenuCursor() {
      if (this.activeBattleMenu !== ACTIVE_BATTLE_MENU.BATTLE_MOVE_SELECT) {
        return;
      }
      switch (this.selectedAttackMoveOption) {
        case ATTACK_MOVE_OPTIONS.MOVE_1:
          this.attackBattleMenuCursorPhaserImageGameObject.setPosition(ATTACK_MENU_CURSOR_POSITION.x, ATTACK_MENU_CURSOR_POSITION.y);
          return;
        case ATTACK_MOVE_OPTIONS.MOVE_2:
          this.attackBattleMenuCursorPhaserImageGameObject.setPosition(228, ATTACK_MENU_CURSOR_POSITION.y);
          return;
        case ATTACK_MOVE_OPTIONS.MOVE_3:
          this.attackBattleMenuCursorPhaserImageGameObject.setPosition(ATTACK_MENU_CURSOR_POSITION.x, 90);
          return;
        case ATTACK_MOVE_OPTIONS.MOVE_4:
          this.attackBattleMenuCursorPhaserImageGameObject.setPosition(228, 90);
          return;
        default:
          exhaustiveGuard(this.selectedAttackMoveOption);
      }
    }
    switchToMainBattleMenu() {
      this.waitingForPlayerInput = false;
      this.hideInputCursor();
      this.hideMonsterAttackSubMenu();
      this.showMainBattleMenu();
    }
    handlePlayerChooseMainBattleOption() {
      this.hideMainBattleMenu();
      if (this.selectedBattleMenuOption === BATTLE_MENU_OPTIONS.FIGHT) {
        this.showMonsterAttackSubMenu();
        this.activeBattleMenu = ACTIVE_BATTLE_MENU.BATTLE_MOVE_SELECT;
        return;
      }
      if (this.selectedBattleMenuOption === BATTLE_MENU_OPTIONS.SWITCH) {
        this.updateInfoPaneMessagesAndWaitForInput(["You have no other monsters..."], () => {
          this.switchToMainBattleMenu();
        });
        this.activeBattleMenu = ACTIVE_BATTLE_MENU.BATTLE_SWITCH;
        return;
      }
      if (this.selectedBattleMenuOption === BATTLE_MENU_OPTIONS.ITEM) {
        this.updateInfoPaneMessagesAndWaitForInput(["Your bag is empty..."], () => {
          this.switchToMainBattleMenu();
        });
        this.activeBattleMenu = ACTIVE_BATTLE_MENU.BATTLE_ITEM;
        return;
      }
      if (this.selectedBattleMenuOption === BATTLE_MENU_OPTIONS.FLEE) {
        this.updateInfoPaneMessagesAndWaitForInput(["You can't flee..."], () => {
          this.switchToMainBattleMenu();
        });
        this.activeBattleMenu = ACTIVE_BATTLE_MENU.BATTLE_FLEE;
        return;
      }
      exhaustiveGuard(this.selectedBattleMenuOption);
    }
    handlePlayerChooseAttack() {
      let selectedAttackMoveIndex;
      switch (this.selectedAttackMoveOption) {
        case ATTACK_MOVE_OPTIONS.MOVE_1:
          selectedAttackMoveIndex = 0;
          break;
        case ATTACK_MOVE_OPTIONS.MOVE_2:
          selectedAttackMoveIndex = 1;
          break;
        case ATTACK_MOVE_OPTIONS.MOVE_3:
          selectedAttackMoveIndex = 2;
          break;
        case ATTACK_MOVE_OPTIONS.MOVE_4:
          selectedAttackMoveIndex = 3;
          break;
        default:
          exhaustiveGuard(this.selectedAttackMoveOption);
          selectedAttackMoveIndex = -1;
      }
      this.selectedAttackIndex = selectedAttackMoveIndex;
    }
    createPlayerInputCursor() {
      this.userInputCursorPhaserImageObject = this.scene.add.image(390, 0, UI_ASSET_KEYS.CURSOR).setAngle(90).setScale(2, 1.5).setAlpha(0);
      this.userInputCursorPhaserTween = this.scene.add.tween({
        delay: 0,
        duration: 800,
        repeat: -1,
        y: {
          from: PLAYER_INPUT_CURSOR_POSITION2.y + 7,
          start: PLAYER_INPUT_CURSOR_POSITION2.y + 7,
          to: PLAYER_INPUT_CURSOR_POSITION2.y + 12
        },
        targets: this.userInputCursorPhaserImageObject
      });
      this.userInputCursorPhaserTween.pause();
    }
  };

  // src/battle/background.ts
  var Background = class {
    scene;
    backgroundGameObject;
    constructor(scene) {
      this.scene = scene;
      this.backgroundGameObject = this.scene.add.image(0, 0, BATTLE_BACKGROUND_ASSET_KEYS.FOREST).setOrigin(0).setAlpha(0);
    }
    showForest() {
      this.backgroundGameObject.setTexture(BATTLE_BACKGROUND_ASSET_KEYS.FOREST).setAlpha(1);
    }
  };

  // src/battle/ui/health-bar.ts
  var HealthBar = class {
    scene;
    healthBarContainer;
    fullWidth;
    scaleY;
    leftCap;
    middle;
    rightCap;
    leftShadowCap;
    middleShadow;
    rightShadowCap;
    constructor(scene, x, y) {
      this.scene = scene;
      this.fullWidth = 360;
      this.scaleY = 0.7;
      this.healthBarContainer = this.scene.add.container(x, y, []);
      this.createHealthBarShadowImages(x, y);
      this.createHealthBarImages(x, y);
      this.setMeterPercentage(1);
    }
    get container() {
      return this.healthBarContainer;
    }
    createHealthBarShadowImages(x, y) {
      this.leftShadowCap = this.scene.add.image(x, y, HEALTH_BAR_ASSET_KEYS.LEFT_CAP_SHADOW).setOrigin(0, 0.5).setScale(1, this.scaleY);
      this.middleShadow = this.scene.add.image(this.leftShadowCap.x + this.leftShadowCap.width, y, HEALTH_BAR_ASSET_KEYS.MIDDLE_SHADOW).setOrigin(0, 0.5).setScale(1, this.scaleY);
      this.middleShadow.displayWidth = this.fullWidth;
      this.rightShadowCap = this.scene.add.image(this.middleShadow.x + this.middleShadow.displayWidth, y, HEALTH_BAR_ASSET_KEYS.RIGHT_CAP_SHADOW).setOrigin(0, 0.5).setScale(1, this.scaleY);
      this.healthBarContainer.add([this.leftShadowCap, this.middleShadow, this.rightShadowCap]);
    }
    createHealthBarImages(x, y) {
      this.leftCap = this.scene.add.image(x, y, HEALTH_BAR_ASSET_KEYS.LEFT_CAP).setOrigin(0, 0.5).setScale(1, this.scaleY);
      this.middle = this.scene.add.image(this.leftCap.x + this.leftCap.width, y, HEALTH_BAR_ASSET_KEYS.MIDDLE).setOrigin(0, 0.5).setScale(1, this.scaleY);
      this.rightCap = this.scene.add.image(this.middle.x + this.middle.displayWidth, y, HEALTH_BAR_ASSET_KEYS.RIGHT_CAP).setOrigin(0, 0.5).setScale(1, this.scaleY);
      this.healthBarContainer.add([this.leftCap, this.middle, this.rightCap]);
    }
    setMeterPercentage(percent = 1) {
      this.middle.displayWidth = this.fullWidth * percent;
      this.rightCap.x = this.middle.x + this.middle.displayWidth;
    }
    setMeterPercentageAnimated(percent = 1, options) {
      const width = this.fullWidth * percent;
      this.scene.tweens.add({
        targets: this.middle,
        displayWidth: width,
        duration: options?.duration ?? 1e3,
        ease: phaser_default.Math.Easing.Sine.Out,
        onUpdate: () => {
          this.rightCap.x = this.middle.x + this.middle.displayWidth;
          const isVisible = this.middle.displayWidth > 0;
          this.leftCap.visible = isVisible;
          this.rightCap.visible = isVisible;
        },
        onComplete: options?.callback
      });
    }
  };

  // src/battle/monsters/battle-monster.ts
  var BattleMonster = class {
    scene;
    monsterDetails;
    healthBar;
    phaserGameObject;
    currentHealth;
    maxHealth;
    monsterAttacks;
    phaserHealthBarGameContainer;
    skipBattleAnimations;
    constructor(config, position) {
      this.scene = config.scene;
      this.monsterDetails = config.monsterDetails;
      this.currentHealth = this.monsterDetails.currentHp;
      this.maxHealth = this.monsterDetails.maxHp;
      this.monsterAttacks = [];
      this.skipBattleAnimations = config.skipBattleAnimations || false;
      this.phaserGameObject = this.scene.add.image(position.x, position.y, this.monsterDetails.assetKey, this.monsterDetails.assetFrame ?? 0).setAlpha(0);
      this.createHealthBarComponent(config.scaleHealthBarBackgroundImageByY);
      this.healthBar.setMeterPercentage(this.currentHealth / this.maxHealth);
      this.monsterDetails.attackIds.forEach((attackId) => {
        const monsterAttack = DataUtils.getMonsterAttack(this.scene, attackId);
        if (monsterAttack !== void 0) {
          this.monsterAttacks.push(monsterAttack);
        }
      });
    }
    get isFainted() {
      return this.currentHealth <= 0;
    }
    get name() {
      return this.monsterDetails.name;
    }
    get attacks() {
      return [...this.monsterAttacks];
    }
    get baseAttack() {
      return this.monsterDetails.baseAttack;
    }
    get level() {
      return this.monsterDetails.currentLevel;
    }
    takeDamage(damage, callback) {
      this.currentHealth -= damage;
      if (this.currentHealth < 0) {
        this.currentHealth = 0;
      }
      this.healthBar.setMeterPercentageAnimated(this.currentHealth / this.maxHealth, {callback});
    }
    playMonsterTakeDamageAnimation(callback) {
      if (this.skipBattleAnimations) {
        this.phaserGameObject.setAlpha(1);
        callback();
        return;
      }
      this.scene.tweens.add({
        delay: 0,
        duration: 150,
        targets: this.phaserGameObject,
        alpha: 0,
        repeat: 5,
        onComplete: () => {
          this.phaserGameObject.setAlpha(1);
          callback();
        }
      });
    }
    playMonsterDeathAnimation(callback) {
      console.log(callback);
      throw new Error("playMonsterDeathAnimation is not implemented.");
    }
    createHealthBarComponent(scaleHealthBarByBackgroundImageByY = 1) {
      this.healthBar = new HealthBar(this.scene, 34, 34);
      const monsterNameGameText = this.scene.add.text(30, 20, this.monsterDetails.name, {
        fontFamily: CUSTOM_FONTS.POKEROGUE,
        color: "#7E3D3F",
        fontSize: "32px"
      });
      const healthBarBackgroundImage = this.scene.add.image(0, 0, BATTLE_ASSET_KEYS.HEALTH_BAR_BACKGROUND).setOrigin(0).setScale(1, scaleHealthBarByBackgroundImageByY);
      const monsterHealthBarLevelText = this.scene.add.text(monsterNameGameText.width + 35, 23, `L${this.level}`, {
        fontFamily: CUSTOM_FONTS.POKEROGUE,
        color: "#ED474B",
        fontSize: "28px"
      });
      const monsterHpText = this.scene.add.text(30, 54, "HP", {
        fontFamily: CUSTOM_FONTS.POKEROGUE,
        color: "#FF6505",
        fontSize: "24px",
        fontStyle: "italic"
      });
      this.phaserHealthBarGameContainer = this.scene.add.container(0, 0, [
        healthBarBackgroundImage,
        monsterNameGameText,
        this.healthBar.container,
        monsterHealthBarLevelText,
        monsterHpText
      ]).setAlpha(0);
    }
  };

  // src/battle/monsters/enemy-battle-monster.ts
  var ENEMY_POSITION = Object.freeze({
    x: 769,
    y: 144
  });
  var EnemyBattleMonster = class extends BattleMonster {
    constructor(config) {
      super({...config, scaleHealthBarBackgroundImageByY: 0.8}, ENEMY_POSITION);
    }
    playMonsterAppearAnimation(callback) {
      const startXPosition = -100;
      const endXPosition = ENEMY_POSITION.x;
      this.phaserGameObject.setPosition(startXPosition, ENEMY_POSITION.y);
      this.phaserGameObject.setAlpha(1);
      if (this.skipBattleAnimations) {
        this.phaserGameObject.setX(endXPosition);
        callback();
        return;
      }
      this.scene.tweens.add({
        delay: 0,
        duration: 1e3,
        targets: this.phaserGameObject,
        x: endXPosition,
        onComplete: () => {
          callback();
        }
      });
    }
    playMonsterHealthBarAppearAnimation(callback) {
      const startXPosition = -600;
      const endXPosition = this.phaserHealthBarGameContainer.x;
      this.phaserHealthBarGameContainer.setPosition(startXPosition, this.phaserHealthBarGameContainer.y);
      this.phaserHealthBarGameContainer.setAlpha(1);
      if (this.skipBattleAnimations) {
        this.phaserHealthBarGameContainer.setX(endXPosition);
        callback();
        return;
      }
      this.scene.tweens.add({
        delay: 0,
        duration: 500,
        targets: this.phaserHealthBarGameContainer,
        x: endXPosition,
        onComplete: () => {
          callback();
        }
      });
    }
    playMonsterDeathAnimation(callback) {
      const endYPosition = this.phaserGameObject.y - 400;
      if (this.skipBattleAnimations) {
        this.phaserGameObject.setY(endYPosition);
        callback();
        return;
      }
      this.scene.tweens.add({
        delay: 0,
        duration: 1e3,
        targets: this.phaserGameObject,
        y: endYPosition,
        onComplete: () => {
          callback();
        }
      });
    }
  };

  // src/battle/monsters/player-battle-monster.ts
  var PLAYER_POSITION = Object.freeze({
    x: 256,
    y: 316
  });
  var PlayerBattleMonster = class extends BattleMonster {
    healthBarTextGameObject;
    constructor(config) {
      super(config, PLAYER_POSITION);
      this.phaserGameObject.setFlipX(true);
      this.phaserHealthBarGameContainer.setPosition(556, 318);
      this.addHealthBarComponent();
    }
    playMonsterAppearAnimation(callback) {
      const startXPosition = 1024;
      const endXPosition = PLAYER_POSITION.x;
      this.phaserGameObject.setPosition(startXPosition, PLAYER_POSITION.y);
      this.phaserGameObject.setAlpha(1);
      if (this.skipBattleAnimations) {
        this.phaserGameObject.setX(endXPosition);
        callback();
        return;
      }
      this.scene.tweens.add({
        delay: 0,
        duration: 1e3,
        targets: this.phaserGameObject,
        x: endXPosition,
        onComplete: () => {
          callback();
        }
      });
    }
    playMonsterHealthBarAppearAnimation(callback) {
      const startXPosition = 1024;
      const endXPosition = this.phaserHealthBarGameContainer.x;
      this.phaserHealthBarGameContainer.setPosition(startXPosition, this.phaserHealthBarGameContainer.y);
      this.phaserHealthBarGameContainer.setAlpha(1);
      if (this.skipBattleAnimations) {
        this.phaserHealthBarGameContainer.setX(endXPosition);
        callback();
        return;
      }
      this.scene.tweens.add({
        delay: 0,
        duration: 500,
        targets: this.phaserHealthBarGameContainer,
        x: endXPosition,
        onComplete: () => {
          callback();
        }
      });
    }
    playMonsterDeathAnimation(callback) {
      const endYPosition = this.phaserGameObject.y + 400;
      if (this.skipBattleAnimations) {
        this.phaserGameObject.setY(endYPosition);
        callback();
        return;
      }
      this.scene.tweens.add({
        delay: 0,
        duration: 1e3,
        targets: this.phaserGameObject,
        y: endYPosition,
        onComplete: () => {
          callback();
        }
      });
    }
    setHealthBarText() {
      this.healthBarTextGameObject.setText(`${this.currentHealth}/${this.maxHealth}`);
    }
    addHealthBarComponent() {
      this.healthBarTextGameObject = this.scene.add.text(443, 80, "", {
        fontFamily: CUSTOM_FONTS.POKEROGUE,
        color: "7E3D3F",
        fontSize: "16px"
      }).setOrigin(1, 0);
      this.setHealthBarText();
      this.phaserHealthBarGameContainer.add(this.healthBarTextGameObject);
    }
    takeDamage(damage, callback) {
      super.takeDamage(damage, callback);
      this.setHealthBarText();
    }
  };

  // src/utils/state-machine.ts
  var StateMachine = class {
    states;
    currentState;
    id;
    context;
    isChangingState;
    ChangingStateQueue;
    constructor(id, context) {
      this.id = id;
      this.context = context;
      this.isChangingState = false;
      this.ChangingStateQueue = [];
      this.currentState = void 0;
      this.states = new Map();
    }
    get currentStateName() {
      return this.currentState?.name;
    }
    update() {
      if (this.ChangingStateQueue.length > 0) {
        this.setState(this.ChangingStateQueue.shift());
      }
    }
    setState(name) {
      const methodName = "setState";
      if (!this.states.has(name)) {
        console.warn(`[${StateMachine.name}-${this.id}:${methodName}] tried to change to unknown state: ${name}`);
        return;
      }
      if (this.isCurrentState(name)) {
        return;
      }
      if (this.isChangingState) {
        this.ChangingStateQueue.push(name);
        return;
      }
      this.isChangingState = true;
      this.currentState = this.states.get(name);
      if (this.currentState) {
        this.currentState.onEnter?.();
      }
      this.isChangingState = false;
    }
    addState(state) {
      this.states.set(state.name, {
        name: state.name,
        onEnter: this.context ? state.onEnter?.bind(this.context) : state.onEnter
      });
    }
    isCurrentState(name) {
      if (!this.currentState) {
        return false;
      }
      return this.currentState.name === name;
    }
  };

  // src/battle/attacks/attack-keys.ts
  var ATTACK_KEYS = Object.freeze({
    ICE_SHARD: "ICE_SHARD",
    SLASH: "SLASH"
  });

  // src/battle/attacks/attack.ts
  var Attack = class {
    scene;
    position;
    isAnimationPlaying;
    attackGameObject;
    constructor(scene, position) {
      this.scene = scene;
      this.position = position;
      this.isAnimationPlaying = false;
      this.attackGameObject = void 0;
    }
    getGameObject() {
      return this.attackGameObject;
    }
    playAnimation(callback) {
      console.log(callback);
      throw new Error("Parent class can't have animations");
    }
  };

  // src/battle/attacks/ice-shard.ts
  var IceShard = class extends Attack {
    attackGameObject;
    constructor(scene, position) {
      super(scene, position);
      this.attackGameObject = this.scene.add.sprite(this.position.x, this.position.y, ATTACK_ASSET_KEYS.ICE_SHARD, 5).setOrigin(0.5).setScale(4).setAlpha(0);
    }
    playAnimation(callback) {
      if (this.isAnimationPlaying) {
        return;
      }
      this.isAnimationPlaying = true;
      this.attackGameObject.setAlpha(1);
      this.attackGameObject.play(ATTACK_ASSET_KEYS.ICE_SHARD_START);
      this.attackGameObject.once(Phaser.Animations.Events.ANIMATION_COMPLETE_KEY + ATTACK_ASSET_KEYS.ICE_SHARD_START, () => {
        this.attackGameObject.play(ATTACK_ASSET_KEYS.ICE_SHARD);
      });
      this.attackGameObject.once(Phaser.Animations.Events.ANIMATION_COMPLETE_KEY + ATTACK_ASSET_KEYS.ICE_SHARD, () => {
        this.isAnimationPlaying = false;
        this.attackGameObject.setAlpha(0).setFrame(0);
        if (callback) {
          callback();
        }
      });
    }
  };

  // src/battle/attacks/slash.ts
  var Slash = class extends Attack {
    attackGameObject;
    attackGameObject1;
    attackGameObject2;
    attackGameObject3;
    constructor(scene, position) {
      super(scene, position);
      this.attackGameObject1 = this.scene.add.sprite(0, 0, ATTACK_ASSET_KEYS.SLASH, 0).setOrigin(0.5).setScale(4);
      this.attackGameObject2 = this.scene.add.sprite(30, 0, ATTACK_ASSET_KEYS.SLASH, 0).setOrigin(0.5).setScale(4);
      this.attackGameObject3 = this.scene.add.sprite(-30, 0, ATTACK_ASSET_KEYS.SLASH, 0).setOrigin(0.5).setScale(4);
      this.attackGameObject = this.scene.add.container(this.position.x, this.position.y, [
        this.attackGameObject1,
        this.attackGameObject2,
        this.attackGameObject3
      ]).setAlpha(0);
    }
    playAnimation(callback) {
      if (this.isAnimationPlaying) {
        return;
      }
      this.isAnimationPlaying = true;
      this.attackGameObject.setAlpha(1);
      this.attackGameObject1.play(ATTACK_ASSET_KEYS.SLASH);
      this.attackGameObject2.play(ATTACK_ASSET_KEYS.SLASH);
      this.attackGameObject3.play(ATTACK_ASSET_KEYS.SLASH);
      this.attackGameObject1.once(Phaser.Animations.Events.ANIMATION_COMPLETE_KEY + ATTACK_ASSET_KEYS.SLASH, () => {
        this.isAnimationPlaying = false;
        this.attackGameObject.setAlpha(0);
        this.attackGameObject1.setFrame(0);
        this.attackGameObject2.setFrame(0);
        this.attackGameObject3.setFrame(0);
        callback?.();
      });
    }
  };

  // src/battle/attacks/attack-manager.ts
  var ATTACK_TARGET = Object.freeze({
    PLAYER: "PLAYER",
    ENEMY: "ENEMY"
  });
  var AttackManager = class {
    scene;
    skipBattleAnimations;
    iceShardAttack;
    slashAttack;
    constructor(scene, skipBattleAnimations) {
      this.scene = scene;
      this.skipBattleAnimations = skipBattleAnimations;
    }
    playAttackAnimation(attack, target, callback) {
      if (this.skipBattleAnimations) {
        callback();
        return;
      }
      let x = 745;
      let y = 140;
      if (target === ATTACK_TARGET.PLAYER) {
        x = 256;
        y = 344;
      }
      switch (attack) {
        case ATTACK_KEYS.ICE_SHARD:
          if (!this.iceShardAttack) {
            this.iceShardAttack = new IceShard(this.scene, {x, y});
          }
          this.iceShardAttack.getGameObject()?.setPosition(x, y);
          this.iceShardAttack.playAnimation(callback);
          break;
        case ATTACK_KEYS.SLASH:
          if (!this.slashAttack) {
            this.slashAttack = new Slash(this.scene, {x, y});
          }
          this.slashAttack.getGameObject()?.setPosition(x, y);
          this.slashAttack.playAnimation(callback);
          break;
        default:
          exhaustiveGuard(attack);
      }
    }
  };

  // src/utils/scene-transition.ts
  function sceneTransition(scene, options) {
    const skipSceneTransition = options.skipSceneTransition || false;
    if (skipSceneTransition) {
      options.callback?.();
      return;
    }
    const {width, height} = scene.scale;
    const rectShape = new Phaser.Geom.Rectangle(0, height / 2, width, 0);
    const g = scene.add.graphics().fillRectShape(rectShape).setDepth(-1);
    const mask = g.createGeometryMask();
    scene.cameras.main.setMask(mask);
    scene.tweens.add({
      onUpdate: () => {
        g.clear().fillRectShape(rectShape);
      },
      delay: 400,
      duration: 800,
      height: {
        ease: Phaser.Math.Easing.Expo.InOut,
        from: 0,
        start: 0,
        to: height
      },
      y: {
        ease: Phaser.Math.Easing.Expo.InOut,
        from: height / 2,
        start: height / 2,
        to: 0
      },
      targets: rectShape,
      onComplete: () => {
        mask.destroy();
        scene.cameras.main.clearMask();
        options.callback?.();
      }
    });
    options.callback?.();
  }

  // src/lib/scenes/battle-scene.ts
  var BATTLE_STATES = Object.freeze({
    INTRO: "INTRO",
    PRE_BATTLE_INFO: "PRE_BATTLE_INFO",
    BRING_OUT_MONSTER: "BRING_OUT_MONSTER",
    PLAYER_INPUT: "PLAYER_INPUT",
    ENEMY_INPUT: "ENEMY_INPUT",
    BATTLE: "BATTLE",
    POST_ATTACK_CHECK: "POST_ATTACK_CHECK",
    FINISHED: "FINISHED",
    FLEE_ATTEMPT: "FLEE_ATTEMPT"
  });
  var BattleScene = class extends phaser_default.Scene {
    battleMenu;
    activeEnemyMonster;
    activePlayerMonster;
    activePlayerAttackIndex;
    battleStateMachine;
    attackManager;
    controls;
    skipAnimations;
    constructor() {
      super({
        key: SCENE_KEYS.BATTLE_SCENE
      });
    }
    init() {
      this.activePlayerAttackIndex = -1;
      const chosenBattleSeenOption = dataManager.getStore.get(DATA_MANAGER_STORE_KEYS.OPTIONS_BATTLE_SCENE_ANIMATIONS);
      if (chosenBattleSeenOption === void 0 || chosenBattleSeenOption === BATTLE_SCENE_OPTIONS.ON) {
        this.skipAnimations = false;
        return;
      }
      this.skipAnimations = true;
    }
    create() {
      const background = new Background(this);
      background.showForest();
      this.activeEnemyMonster = new EnemyBattleMonster({
        scene: this,
        monsterDetails: {
          name: MONSTER_ASSET_KEYS.CARNODUSK,
          assetKey: MONSTER_ASSET_KEYS.CARNODUSK,
          assetFrame: 0,
          currentLevel: 5,
          currentHp: 20,
          maxHp: 25,
          attackIds: [1, 2],
          baseAttack: 25
        },
        skipBattleAnimations: this.skipAnimations
      });
      this.activePlayerMonster = new PlayerBattleMonster({
        scene: this,
        monsterDetails: {
          name: MONSTER_ASSET_KEYS.IGUANIGNITE,
          assetKey: MONSTER_ASSET_KEYS.IGUANIGNITE,
          assetFrame: 0,
          currentLevel: 5,
          currentHp: 25,
          maxHp: 25,
          attackIds: [1, 2],
          baseAttack: 15
        },
        skipBattleAnimations: this.skipAnimations
      });
      this.battleMenu = new BattleMenu(this, this.activePlayerMonster, this.skipAnimations);
      this.createBattleStateMachine();
      this.attackManager = new AttackManager(this, this.skipAnimations);
      this.controls = new Controls(this);
      this.controls.lockInput = true;
    }
    update() {
      this.battleStateMachine.update();
      if (this.controls.isInputLocked) {
        return;
      }
      const wasSpaceKeyPressed = this.controls.wasSpaceKeyPressed();
      if (wasSpaceKeyPressed && (this.battleStateMachine.currentStateName === BATTLE_STATES.PRE_BATTLE_INFO || this.battleStateMachine.currentStateName === BATTLE_STATES.POST_ATTACK_CHECK || this.battleStateMachine.currentStateName === BATTLE_STATES.BRING_OUT_MONSTER || this.battleStateMachine.currentStateName === BATTLE_STATES.FLEE_ATTEMPT)) {
        this.battleMenu.handlePlayerInput("OK");
        return;
      }
      if (this.battleStateMachine.currentStateName !== BATTLE_STATES.PLAYER_INPUT) {
        return;
      }
      if (wasSpaceKeyPressed) {
        this.battleMenu.handlePlayerInput("OK");
        if (this.battleMenu.selectedAttack === void 0) {
          return;
        }
        this.activePlayerAttackIndex = this.battleMenu.selectedAttack;
        if (!this.activePlayerMonster.attacks[this.activePlayerAttackIndex]) {
          return;
        }
        this.battleMenu.hideMonsterAttackSubMenu();
        this.battleStateMachine.setState(BATTLE_STATES.ENEMY_INPUT);
      }
      if (this.controls.wasBackKeyPressed()) {
        this.battleMenu.handlePlayerInput("CANCEL");
        return;
      }
      let selectedDirection = this.controls.getDirectionKeyPressedDown();
      if (selectedDirection !== DIRECTION.NONE) {
        this.battleMenu.handlePlayerInput(selectedDirection);
      }
    }
    playerAttack() {
      if (this.activePlayerMonster.isFainted) {
        return;
      }
      this.battleMenu.updateInfoPaneMessagesNoInputRequired(`${this.activePlayerMonster.name} used ${this.activePlayerMonster.attacks[this.activePlayerAttackIndex].name}`, () => {
        this.time.delayedCall(1200, () => {
          this.attackManager.playAttackAnimation(this.activePlayerMonster.attacks[this.activePlayerAttackIndex].animationName, ATTACK_TARGET.ENEMY, () => {
            this.activeEnemyMonster.playMonsterTakeDamageAnimation(() => {
              this.activeEnemyMonster.takeDamage(this.activePlayerMonster.baseAttack, () => {
                this.enemyAttack();
              });
            });
          });
        });
      });
    }
    enemyAttack() {
      if (this.activeEnemyMonster.isFainted) {
        this.battleStateMachine.setState(BATTLE_STATES.POST_ATTACK_CHECK);
        return;
      }
      this.battleMenu.updateInfoPaneMessagesNoInputRequired(`${this.activeEnemyMonster.name} used ${this.activeEnemyMonster.attacks[0].name}`, () => {
        this.time.delayedCall(1200, () => {
          this.attackManager.playAttackAnimation(this.activeEnemyMonster.attacks[0].animationName, ATTACK_TARGET.PLAYER, () => {
            this.activePlayerMonster.playMonsterTakeDamageAnimation(() => {
              this.activePlayerMonster.takeDamage(this.activeEnemyMonster.baseAttack, () => {
                this.battleStateMachine.setState(BATTLE_STATES.POST_ATTACK_CHECK);
              });
            });
          });
        });
      });
    }
    postBattleSequenceCheck() {
      if (this.activeEnemyMonster.isFainted) {
        this.battleMenu.updateInfoPaneMessagesAndWaitForInput([`Wild ${this.activeEnemyMonster.name} fucking died.`, `${this.activeEnemyMonster.name} gained experience`], () => {
          this.time.delayedCall(500, () => {
            this.activeEnemyMonster.playMonsterDeathAnimation(() => {
              this.battleStateMachine.setState(BATTLE_STATES.FINISHED);
            });
          });
        });
        return;
      }
      if (this.activePlayerMonster.isFainted) {
        this.battleMenu.updateInfoPaneMessagesAndWaitForInput([`${this.activePlayerMonster.name} fainted`, "You have no more monsters, escaping to safety..."], () => {
          this.activePlayerMonster.playMonsterDeathAnimation(() => {
            this.time.delayedCall(500, () => {
              this.battleStateMachine.setState(BATTLE_STATES.FINISHED);
            });
          });
        });
        return;
      }
      this.battleStateMachine.setState(BATTLE_STATES.PLAYER_INPUT);
    }
    transitionToNextScene() {
      this.cameras.main.fadeOut(600, 0, 0, 0);
      this.cameras.main.once(phaser_default.Cameras.Scene2D.Events.FADE_OUT_COMPLETE, () => {
        this.scene.start(SCENE_KEYS.BATTLE_SCENE);
      });
    }
    createBattleStateMachine() {
      this.battleStateMachine = new StateMachine("battle", this);
      this.battleStateMachine.addState({
        name: BATTLE_STATES.INTRO,
        onEnter: () => {
          sceneTransition(this, {
            skipSceneTransition: this.skipAnimations,
            callback: () => {
              this.battleStateMachine.setState(BATTLE_STATES.PRE_BATTLE_INFO);
            }
          });
        }
      });
      this.battleStateMachine.addState({
        name: BATTLE_STATES.PRE_BATTLE_INFO,
        onEnter: () => {
          this.activeEnemyMonster.playMonsterAppearAnimation(() => {
            this.activeEnemyMonster.playMonsterHealthBarAppearAnimation(() => void 0);
            this.controls.lockInput = false;
            this.battleMenu.updateInfoPaneMessagesAndWaitForInput([`Wild ${this.activeEnemyMonster.name} appeared`], () => {
              this.time.delayedCall(500, () => {
                this.battleStateMachine.setState(BATTLE_STATES.BRING_OUT_MONSTER);
              });
            });
          });
        }
      });
      this.battleStateMachine.addState({
        name: BATTLE_STATES.BRING_OUT_MONSTER,
        onEnter: () => {
          this.battleMenu.updateInfoPaneMessagesAndWaitForInput([`Go ${this.activePlayerMonster.name}`], () => {
            this.time.delayedCall(500, () => {
              this.battleStateMachine.setState(BATTLE_STATES.PLAYER_INPUT);
            });
          });
          this.activePlayerMonster.playMonsterAppearAnimation(() => {
            this.activePlayerMonster.playMonsterHealthBarAppearAnimation(() => void 0);
          });
        }
      });
      this.battleStateMachine.addState({
        name: BATTLE_STATES.PLAYER_INPUT,
        onEnter: () => {
          this.battleMenu.showMainBattleMenu();
        }
      });
      this.battleStateMachine.addState({
        name: BATTLE_STATES.ENEMY_INPUT,
        onEnter: () => {
          this.battleStateMachine.setState(BATTLE_STATES.BATTLE);
        }
      });
      this.battleStateMachine.addState({
        name: BATTLE_STATES.BATTLE,
        onEnter: () => {
          this.playerAttack();
        }
      });
      this.battleStateMachine.addState({
        name: BATTLE_STATES.POST_ATTACK_CHECK,
        onEnter: () => {
          this.postBattleSequenceCheck();
        }
      });
      this.battleStateMachine.addState({
        name: BATTLE_STATES.FINISHED,
        onEnter: () => {
          this.transitionToNextScene();
        }
      });
      this.battleStateMachine.addState({
        name: BATTLE_STATES.FLEE_ATTEMPT,
        onEnter: () => {
          this.battleMenu.updateInfoPaneMessagesAndWaitForInput(["You got away safely"], () => {
            this.battleStateMachine.setState(BATTLE_STATES.FINISHED);
          });
        }
      });
      this.battleStateMachine.setState("INTRO");
    }
  };

  // src/lib/scenes/options-scene.ts
  var OPTIONS_TEXT_STYLE = Object.freeze({
    fontFamily: CUSTOM_FONTS.POKEROGUE,
    color: "#FFFFFF",
    fontSize: "35px"
  });
  var OPTION_MENU_OPTION_INFO_MSG = Object.freeze({
    TEXT_SPEED: "Choose one of three text speeds.",
    BATTLE_SCENE: "Choose to display battle animations and effects.",
    SOUND: "Choose to enable or disable sound.",
    VOLUME: "Set volume value.",
    MENU_COLOR: "Choose one of three menu color options.",
    CLOSE: "Confirm and close."
  });
  var TEXT_FONT_COLORS = Object.freeze({
    NOT_SELECTED: "#FFFFFF",
    SELECTED: "#FF2222"
  });
  var OptionsScene = class extends phaser_default.Scene {
    mainContainer;
    nineSliceMainContainer;
    textSpeedOptionTextGameObjects;
    battleSceneOptionTextGameObjects;
    soundOptionTextGameObjects;
    volumeOptionTextGameObjects;
    menuColorOptionTextGameObjects;
    volumeOptionMenuCursor;
    volumeOptionValueText;
    selectedMenuColorTextGameObject;
    infoContainer;
    selectedOptionInfoMsgTextGameObject;
    optionsMenuCursor;
    controls;
    selectedOptionMenu;
    selectedTextSpeedOption;
    selectedBattleSceneOption;
    selectedSoundOption;
    selectedVolumeOption;
    selectedMenuColorOption;
    constructor() {
      super({
        key: SCENE_KEYS.OPTIONS_SCENE
      });
    }
    init() {
      this.nineSliceMainContainer = new NineSlice({
        cornerCutSize: 32,
        textureManager: this.sys.textures,
        assetKeys: [UI_ASSET_KEYS.MENU_BACKGROUND, UI_ASSET_KEYS.MENU_BACKGROUND_GREEN, UI_ASSET_KEYS.MENU_BACKGROUND_PURPLE]
      });
      this.selectedTextSpeedOption = dataManager.getStore.get(DATA_MANAGER_STORE_KEYS.OPTIONS_TEXT_SPEED);
      this.selectedBattleSceneOption = dataManager.getStore.get(DATA_MANAGER_STORE_KEYS.OPTIONS_BATTLE_SCENE_ANIMATIONS);
      this.selectedSoundOption = dataManager.getStore.get(DATA_MANAGER_STORE_KEYS.OPTIONS_SOUND);
      this.selectedVolumeOption = dataManager.getStore.get(DATA_MANAGER_STORE_KEYS.OPTIONS_VOLUME);
      this.selectedMenuColorOption = dataManager.getStore.get(DATA_MANAGER_STORE_KEYS.OPTIONS_MENU_COLOR);
      this.selectedOptionMenu = OPTION_MENU_OPTIONS.TEXT_SPEED;
    }
    create() {
      const {width, height} = this.scale;
      const optionMenuWidth = width - 200;
      this.mainContainer = this.nineSliceMainContainer.createNineSliceContainer(this, optionMenuWidth, 432, UI_ASSET_KEYS.MENU_BACKGROUND);
      this.mainContainer.setX(100).setY(20);
      this.add.text(width / 2, 40, "Options", OPTIONS_TEXT_STYLE).setOrigin(0.5).setScale(1.3);
      const menuOptions = ["Text Speed", "Battle Scene", "Sound", "Volume", "Menu Color", "Close"];
      const menuOptionsPosition = {
        x: 25,
        yStart: 55,
        yIncrement: 55
      };
      menuOptions.forEach((option, index) => {
        const x = menuOptionsPosition.x;
        const y = menuOptionsPosition.yStart + index * menuOptionsPosition.yIncrement;
        const textGameObject = this.add.text(x, y, option, OPTIONS_TEXT_STYLE);
        this.mainContainer.add(textGameObject);
      });
      this.textSpeedOptionTextGameObjects = this.add.group([
        this.add.text(420, 75, "Slow", OPTIONS_TEXT_STYLE),
        this.add.text(590, 75, "Mid", OPTIONS_TEXT_STYLE),
        this.add.text(760, 75, "Fast", OPTIONS_TEXT_STYLE)
      ]);
      this.battleSceneOptionTextGameObjects = this.add.group([
        this.add.text(420, 130, "On", OPTIONS_TEXT_STYLE),
        this.add.text(590, 130, "Off", OPTIONS_TEXT_STYLE)
      ]);
      this.soundOptionTextGameObjects = this.add.group([
        this.add.text(420, 185, "On", OPTIONS_TEXT_STYLE),
        this.add.text(590, 185, "Off", OPTIONS_TEXT_STYLE)
      ]);
      this.add.rectangle(420, 260, 300, 4, 16777215, 1).setOrigin(0, 0.5);
      this.volumeOptionMenuCursor = this.add.rectangle(710, 260, 10, 25, 16720418, 1).setOrigin(0, 0.5);
      this.volumeOptionValueText = this.add.text(760, 238, "100%", OPTIONS_TEXT_STYLE);
      this.selectedMenuColorTextGameObject = this.add.text(590, 295, "", OPTIONS_TEXT_STYLE);
      this.add.image(530, 302, UI_ASSET_KEYS.CURSOR_WHITE).setOrigin(1, 0).setScale(2.5).setFlipX(true);
      this.add.image(660, 302, UI_ASSET_KEYS.CURSOR_WHITE).setOrigin(0, 0).setScale(2.5);
      this.infoContainer = this.nineSliceMainContainer.createNineSliceContainer(this, optionMenuWidth, 100, UI_ASSET_KEYS.MENU_BACKGROUND);
      this.infoContainer.setPosition(100, height - 110);
      this.selectedOptionInfoMsgTextGameObject = this.add.text(125, 480, OPTION_MENU_OPTION_INFO_MSG.TEXT_SPEED, {
        ...OPTIONS_TEXT_STYLE,
        ...{
          wordWrap: {width: width - 250}
        }
      });
      this.optionsMenuCursor = this.add.rectangle(110, 75, optionMenuWidth - 20, 40, 4294967295, 0).setOrigin(0).setStrokeStyle(4, 14959434, 1);
      this.updateTextSpeedGameObjects();
      this.updateBattleSceneGameObjects();
      this.updateSoundGameObjects();
      this.updateVolumeGameObjects();
      this.updateMenuColorGameObjects();
      this.controls = new Controls(this);
      this.cameras.main.once(phaser_default.Cameras.Scene2D.Events.FADE_OUT_COMPLETE, () => {
        this.scene.start(SCENE_KEYS.TITLE_SCENE);
      });
    }
    update() {
      if (this.controls.isInputLocked) {
        return;
      }
      if (this.controls.wasBackKeyPressed()) {
        this.controls.lockInput = true;
        this.cameras.main.fadeOut(500, 0, 0);
        return;
      }
      if (this.controls.wasSpaceKeyPressed() && this.selectedOptionMenu === OPTION_MENU_OPTIONS.CLOSE) {
        this.updateOptionDataManager();
        this.controls.lockInput = true;
        this.cameras.main.fadeOut(500, 0, 0);
        return;
      }
      const selectedDirection = this.controls.getDirectionKeyJustDown();
      if (selectedDirection !== DIRECTION.NONE) {
        this.moveOptionMenuCursor(selectedDirection);
      }
    }
    updateOptionDataManager() {
      dataManager.getStore.set({
        [DATA_MANAGER_STORE_KEYS.OPTIONS_TEXT_SPEED]: this.selectedTextSpeedOption,
        [DATA_MANAGER_STORE_KEYS.OPTIONS_BATTLE_SCENE_ANIMATIONS]: this.selectedBattleSceneOption,
        [DATA_MANAGER_STORE_KEYS.OPTIONS_SOUND]: this.selectedSoundOption,
        [DATA_MANAGER_STORE_KEYS.OPTIONS_VOLUME]: this.selectedVolumeOption,
        [DATA_MANAGER_STORE_KEYS.OPTIONS_MENU_COLOR]: this.selectedMenuColorOption
      });
      dataManager.saveData();
    }
    moveOptionMenuCursor(direction) {
      if (direction === DIRECTION.NONE) {
        return;
      }
      this.updateSelectedOptionMenuFromInput(direction);
      switch (this.selectedOptionMenu) {
        case OPTION_MENU_OPTIONS.TEXT_SPEED:
          this.optionsMenuCursor.setY(75);
          break;
        case OPTION_MENU_OPTIONS.BATTLE_SCENE:
          this.optionsMenuCursor.setY(75 + 55);
          break;
        case OPTION_MENU_OPTIONS.SOUND:
          this.optionsMenuCursor.setY(75 + 55 * 2);
          break;
        case OPTION_MENU_OPTIONS.VOLUME:
          this.optionsMenuCursor.setY(75 + 55 * 3);
          break;
        case OPTION_MENU_OPTIONS.MENU_COLOR:
          this.optionsMenuCursor.setY(75 + 55 * 4);
          break;
        case OPTION_MENU_OPTIONS.CLOSE:
          this.optionsMenuCursor.setY(75 + 55 * 5);
          break;
        default:
          exhaustiveGuard(this.selectedOptionMenu);
      }
      this.selectedOptionInfoMsgTextGameObject.setText(OPTION_MENU_OPTION_INFO_MSG[this.selectedOptionMenu]);
    }
    updateSelectedOptionMenuFromInput(direction) {
      if (direction === DIRECTION.NONE) {
        return;
      }
      if (this.selectedOptionMenu === OPTION_MENU_OPTIONS.TEXT_SPEED) {
        switch (direction) {
          case DIRECTION.DOWN:
            this.selectedOptionMenu = OPTION_MENU_OPTIONS.BATTLE_SCENE;
            return;
          case DIRECTION.UP:
            this.selectedOptionMenu = OPTION_MENU_OPTIONS.CLOSE;
            return;
          case DIRECTION.RIGHT:
          case DIRECTION.LEFT:
            this.updateTextSpeedOption(direction);
            this.updateTextSpeedGameObjects();
            return;
          default:
            exhaustiveGuard(direction);
        }
      }
      if (this.selectedOptionMenu === OPTION_MENU_OPTIONS.BATTLE_SCENE) {
        switch (direction) {
          case DIRECTION.DOWN:
            this.selectedOptionMenu = OPTION_MENU_OPTIONS.SOUND;
            return;
          case DIRECTION.UP:
            this.selectedOptionMenu = OPTION_MENU_OPTIONS.TEXT_SPEED;
            return;
          case DIRECTION.RIGHT:
          case DIRECTION.LEFT:
            this.updateBattleSceneOption(direction);
            this.updateBattleSceneGameObjects();
            return;
          default:
            exhaustiveGuard(direction);
        }
      }
      if (this.selectedOptionMenu === OPTION_MENU_OPTIONS.SOUND) {
        switch (direction) {
          case DIRECTION.DOWN:
            this.selectedOptionMenu = OPTION_MENU_OPTIONS.VOLUME;
            return;
          case DIRECTION.UP:
            this.selectedOptionMenu = OPTION_MENU_OPTIONS.BATTLE_SCENE;
            return;
          case DIRECTION.RIGHT:
          case DIRECTION.LEFT:
            this.updateSoundOption(direction);
            this.updateSoundGameObjects();
            return;
          default:
            exhaustiveGuard(direction);
        }
      }
      if (this.selectedOptionMenu === OPTION_MENU_OPTIONS.VOLUME) {
        switch (direction) {
          case DIRECTION.DOWN:
            this.selectedOptionMenu = OPTION_MENU_OPTIONS.MENU_COLOR;
            return;
          case DIRECTION.UP:
            this.selectedOptionMenu = OPTION_MENU_OPTIONS.SOUND;
            return;
          case DIRECTION.RIGHT:
          case DIRECTION.LEFT:
            this.updateVolumeOption(direction);
            this.updateVolumeGameObjects();
            return;
          default:
            exhaustiveGuard(direction);
        }
      }
      if (this.selectedOptionMenu === OPTION_MENU_OPTIONS.MENU_COLOR) {
        switch (direction) {
          case DIRECTION.DOWN:
            this.selectedOptionMenu = OPTION_MENU_OPTIONS.CLOSE;
            return;
          case DIRECTION.UP:
            this.selectedOptionMenu = OPTION_MENU_OPTIONS.VOLUME;
            return;
          case DIRECTION.RIGHT:
          case DIRECTION.LEFT:
            this.updateMenuColorOption(direction);
            this.updateMenuColorGameObjects();
            return;
          default:
            exhaustiveGuard(direction);
        }
      }
      if (this.selectedOptionMenu === OPTION_MENU_OPTIONS.CLOSE) {
        switch (direction) {
          case DIRECTION.DOWN:
            this.selectedOptionMenu = OPTION_MENU_OPTIONS.TEXT_SPEED;
            return;
          case DIRECTION.UP:
            this.selectedOptionMenu = OPTION_MENU_OPTIONS.MENU_COLOR;
            return;
          case DIRECTION.RIGHT:
          case DIRECTION.LEFT:
            return;
          default:
            exhaustiveGuard(direction);
        }
      }
      exhaustiveGuard(this.selectedOptionMenu);
    }
    updateTextSpeedOption(direction) {
      if (direction === DIRECTION.LEFT) {
        if (this.selectedTextSpeedOption === TEXT_SPEED_OPTIONS.SLOW) {
          return;
        }
        if (this.selectedTextSpeedOption === TEXT_SPEED_OPTIONS.MID) {
          this.selectedTextSpeedOption = TEXT_SPEED_OPTIONS.SLOW;
          return;
        }
        if (this.selectedTextSpeedOption === TEXT_SPEED_OPTIONS.FAST) {
          this.selectedTextSpeedOption = TEXT_SPEED_OPTIONS.MID;
          return;
        }
        exhaustiveGuard(this.selectedTextSpeedOption);
      }
      if (direction === DIRECTION.RIGHT) {
        if (this.selectedTextSpeedOption === TEXT_SPEED_OPTIONS.SLOW) {
          this.selectedTextSpeedOption = TEXT_SPEED_OPTIONS.MID;
          return;
        }
        if (this.selectedTextSpeedOption === TEXT_SPEED_OPTIONS.MID) {
          this.selectedTextSpeedOption = TEXT_SPEED_OPTIONS.FAST;
          return;
        }
        if (this.selectedTextSpeedOption === TEXT_SPEED_OPTIONS.FAST) {
          return;
        }
        exhaustiveGuard(this.selectedTextSpeedOption);
      }
      exhaustiveGuard(direction);
    }
    updateTextSpeedGameObjects() {
      const textGameObjects = this.textSpeedOptionTextGameObjects.getChildren();
      textGameObjects.forEach((obj) => {
        obj.setColor(TEXT_FONT_COLORS.NOT_SELECTED);
      });
      if (this.selectedTextSpeedOption === TEXT_SPEED_OPTIONS.SLOW) {
        textGameObjects[0].setColor(TEXT_FONT_COLORS.SELECTED);
        return;
      }
      if (this.selectedTextSpeedOption === TEXT_SPEED_OPTIONS.MID) {
        textGameObjects[1].setColor(TEXT_FONT_COLORS.SELECTED);
        return;
      }
      if (this.selectedTextSpeedOption === TEXT_SPEED_OPTIONS.FAST) {
        textGameObjects[2].setColor(TEXT_FONT_COLORS.SELECTED);
        return;
      }
      exhaustiveGuard(this.selectedTextSpeedOption);
    }
    updateBattleSceneOption(direction) {
      if (direction === DIRECTION.LEFT) {
        if (this.selectedBattleSceneOption === BATTLE_SCENE_OPTIONS.ON) {
          return;
        }
        if (this.selectedBattleSceneOption === BATTLE_SCENE_OPTIONS.OFF) {
          this.selectedBattleSceneOption = BATTLE_SCENE_OPTIONS.ON;
          return;
        }
        exhaustiveGuard(this.selectedBattleSceneOption);
      }
      if (direction === DIRECTION.RIGHT) {
        if (this.selectedBattleSceneOption === BATTLE_SCENE_OPTIONS.ON) {
          this.selectedBattleSceneOption = BATTLE_SCENE_OPTIONS.OFF;
          return;
        }
        if (this.selectedBattleSceneOption === BATTLE_SCENE_OPTIONS.OFF) {
          return;
        }
        exhaustiveGuard(this.selectedBattleSceneOption);
      }
      exhaustiveGuard(direction);
    }
    updateBattleSceneGameObjects() {
      const textGameObjects = this.battleSceneOptionTextGameObjects.getChildren();
      textGameObjects.forEach((obj) => {
        obj.setColor(TEXT_FONT_COLORS.NOT_SELECTED);
      });
      if (this.selectedBattleSceneOption === BATTLE_SCENE_OPTIONS.ON) {
        textGameObjects[0].setColor(TEXT_FONT_COLORS.SELECTED);
        return;
      }
      if (this.selectedBattleSceneOption === BATTLE_SCENE_OPTIONS.OFF) {
        textGameObjects[1].setColor(TEXT_FONT_COLORS.SELECTED);
        return;
      }
      exhaustiveGuard(this.selectedBattleSceneOption);
    }
    updateSoundOption(direction) {
      if (direction === DIRECTION.LEFT) {
        if (this.selectedSoundOption === SOUND_OPTIONS.ON) {
          return;
        }
        if (this.selectedSoundOption === SOUND_OPTIONS.OFF) {
          this.selectedSoundOption = SOUND_OPTIONS.ON;
          return;
        }
        exhaustiveGuard(this.selectedSoundOption);
      }
      if (direction === DIRECTION.RIGHT) {
        if (this.selectedSoundOption === SOUND_OPTIONS.ON) {
          this.selectedSoundOption = SOUND_OPTIONS.OFF;
          return;
        }
        if (this.selectedSoundOption === SOUND_OPTIONS.OFF) {
          return;
        }
        exhaustiveGuard(this.selectedSoundOption);
      }
      exhaustiveGuard(direction);
    }
    updateSoundGameObjects() {
      const textGameObjects = this.soundOptionTextGameObjects.getChildren();
      textGameObjects.forEach((obj) => {
        obj.setColor(TEXT_FONT_COLORS.NOT_SELECTED);
      });
      if (this.selectedSoundOption === SOUND_OPTIONS.ON) {
        textGameObjects[0].setColor(TEXT_FONT_COLORS.SELECTED);
        return;
      }
      if (this.selectedSoundOption === SOUND_OPTIONS.OFF) {
        textGameObjects[1].setColor(TEXT_FONT_COLORS.SELECTED);
        return;
      }
      exhaustiveGuard(this.selectedSoundOption);
    }
    updateVolumeOption(direction) {
      if (direction === DIRECTION.LEFT) {
        if (this.selectedVolumeOption === 0) {
          return;
        }
        this.selectedVolumeOption = this.selectedVolumeOption - 1;
      }
      if (direction === DIRECTION.RIGHT) {
        if (this.selectedVolumeOption === 4) {
          return;
        }
        this.selectedVolumeOption = this.selectedVolumeOption + 1;
      }
    }
    updateVolumeGameObjects() {
      switch (this.selectedVolumeOption) {
        case 0:
          this.volumeOptionMenuCursor.setX(420);
          this.volumeOptionValueText.setText("0%");
          break;
        case 1:
          this.volumeOptionMenuCursor.setX(490);
          this.volumeOptionValueText.setText("25%");
          break;
        case 2:
          this.volumeOptionMenuCursor.setX(560);
          this.volumeOptionValueText.setText("50%");
          break;
        case 3:
          this.volumeOptionMenuCursor.setX(630);
          this.volumeOptionValueText.setText("75%");
          break;
        case 4:
          this.volumeOptionMenuCursor.setX(710);
          this.volumeOptionValueText.setText("100%");
          break;
        default:
          exhaustiveGuard(this.selectedVolumeOption);
          return;
      }
    }
    updateMenuColorOption(direction) {
      if (direction === DIRECTION.LEFT) {
        if (this.selectedMenuColorOption === 0) {
          this.selectedMenuColorOption = 2;
          return;
        }
        this.selectedMenuColorOption = this.selectedMenuColorOption - 1;
      }
      if (direction === DIRECTION.RIGHT) {
        if (this.selectedMenuColorOption === 2) {
          this.selectedMenuColorOption = 0;
          return;
        }
        this.selectedMenuColorOption = this.selectedMenuColorOption + 1;
      }
    }
    updateMenuColorGameObjects() {
      switch (this.selectedMenuColorOption) {
        case 0:
          this.selectedMenuColorTextGameObject.setText("1");
          this.nineSliceMainContainer.updateNineSliceContainerTexture(this.sys.textures, this.mainContainer, UI_ASSET_KEYS.MENU_BACKGROUND);
          this.nineSliceMainContainer.updateNineSliceContainerTexture(this.sys.textures, this.infoContainer, UI_ASSET_KEYS.MENU_BACKGROUND);
          break;
        case 1:
          this.selectedMenuColorTextGameObject.setText("2");
          this.nineSliceMainContainer.updateNineSliceContainerTexture(this.sys.textures, this.mainContainer, UI_ASSET_KEYS.MENU_BACKGROUND_GREEN);
          this.nineSliceMainContainer.updateNineSliceContainerTexture(this.sys.textures, this.infoContainer, UI_ASSET_KEYS.MENU_BACKGROUND_GREEN);
          break;
        case 2:
          this.selectedMenuColorTextGameObject.setText("3");
          this.nineSliceMainContainer.updateNineSliceContainerTexture(this.sys.textures, this.mainContainer, UI_ASSET_KEYS.MENU_BACKGROUND_PURPLE);
          this.nineSliceMainContainer.updateNineSliceContainerTexture(this.sys.textures, this.infoContainer, UI_ASSET_KEYS.MENU_BACKGROUND_PURPLE);
          break;
        default:
          exhaustiveGuard(this.selectedMenuColorOption);
          return;
      }
    }
  };

  // src/utils/draggable.ts
  function makeDraggable(gameObject) {
    gameObject.setInteractive();
    function onDrag(pointer) {
      gameObject.x = pointer.x;
      gameObject.y = pointer.y;
    }
    function stopDrag() {
      gameObject.on(phaser_default.Input.Events.POINTER_DOWN, startDrag);
      gameObject.off(phaser_default.Input.Events.POINTER_MOVE, onDrag);
      gameObject.off(phaser_default.Input.Events.POINTER_UP, stopDrag);
      gameObject.x = Math.round(gameObject.x);
      gameObject.y = Math.round(gameObject.y);
    }
    function startDrag() {
      gameObject.off(phaser_default.Input.Events.POINTER_DOWN, startDrag);
      gameObject.on(phaser_default.Input.Events.POINTER_MOVE, onDrag);
      gameObject.on(phaser_default.Input.Events.POINTER_UP, stopDrag);
    }
    function destroy() {
      gameObject.off(phaser_default.Input.Events.POINTER_DOWN, startDrag);
      gameObject.off(phaser_default.Input.Events.POINTER_MOVE, onDrag);
      gameObject.off(phaser_default.Input.Events.POINTER_UP, stopDrag);
    }
    gameObject.on(phaser_default.Input.Events.POINTER_DOWN, startDrag);
    gameObject.once(phaser_default.GameObjects.Events.DESTROY, destroy);
  }

  // src/lib/scenes/test-scene.ts
  var TestScene = class extends phaser_default.Scene {
    selectedAttack;
    iceShardAttack;
    slashAttack;
    playerMonster;
    enemyMonster;
    constructor() {
      super({key: SCENE_KEYS.TEST_SCENE});
    }
    init() {
      this.selectedAttack = ATTACK_KEYS.SLASH;
    }
    create() {
      const background = new Background(this);
      background.showForest();
      this.playerMonster = this.add.image(256, 316, MONSTER_ASSET_KEYS.IGUANIGNITE, 0).setFlipX(true);
      this.enemyMonster = this.add.image(768, 144, MONSTER_ASSET_KEYS.CARNODUSK, 0).setFlipX(false);
      makeDraggable(this.playerMonster);
      makeDraggable(this.enemyMonster);
      this.iceShardAttack = new IceShard(this, {x: 256, y: 344});
      this.slashAttack = new Slash(this, {x: 745, y: 140});
      this.addDataGui();
    }
    addDataGui() {
      const pane = new TweakPane.Pane();
      const monstersFolder = pane.addFolder({
        title: "Monsters",
        expanded: true
      });
      const playerMonsterFolder = monstersFolder.addFolder({
        title: "Player",
        expanded: true
      });
      playerMonsterFolder.addBinding(this.playerMonster, "x", {
        min: 0,
        max: 1024,
        step: 1,
        readonly: false
      });
      playerMonsterFolder.addBinding(this.playerMonster, "y", {
        min: 0,
        max: 576,
        step: 1,
        readonly: false
      });
      const enemyMonsterFolder = monstersFolder.addFolder({
        title: "Enemy",
        expanded: true
      });
      enemyMonsterFolder.addBinding(this.enemyMonster, "x", {
        min: 0,
        max: 1024,
        step: 1,
        readonly: false
      });
      enemyMonsterFolder.addBinding(this.enemyMonster, "y", {
        min: 0,
        max: 576,
        step: 1,
        readonly: false
      });
      const attacksFolder = pane.addFolder({
        title: "Attacks",
        expanded: true
      });
      const attacksFolderParams = {
        attack: this.selectedAttack,
        x: 745,
        y: 120
      };
      attacksFolder.addBinding(attacksFolderParams, "attack", {
        options: {
          [ATTACK_KEYS.SLASH]: ATTACK_KEYS.SLASH,
          [ATTACK_KEYS.ICE_SHARD]: ATTACK_KEYS.ICE_SHARD
        }
      }).on("change", (ev) => {
        if (ev.value === ATTACK_KEYS.SLASH) {
          this.selectedAttack = ATTACK_KEYS.SLASH;
          attacksFolderParams.x = this.slashAttack.getGameObject()?.x;
          attacksFolderParams.y = this.slashAttack.getGameObject()?.y;
          attacksFolder.refresh();
          return;
        }
        if (ev.value === ATTACK_KEYS.ICE_SHARD) {
          this.selectedAttack = ATTACK_KEYS.ICE_SHARD;
          attacksFolderParams.x = this.iceShardAttack.getGameObject()?.x;
          attacksFolderParams.y = this.iceShardAttack.getGameObject()?.y;
          attacksFolder.refresh();
          return;
        }
      });
      attacksFolder.addBinding(attacksFolderParams, "x", {
        min: 0,
        max: 1024,
        step: 1,
        readonly: false
      }).on("change", (ev) => {
        this.updateAttackGameObjectPosition("x", ev.value);
      });
      attacksFolder.addBinding(attacksFolderParams, "y", {
        min: 0,
        max: 576,
        step: 1,
        readonly: false
      }).on("change", (ev) => {
        this.updateAttackGameObjectPosition("y", ev.value);
      });
      const playAttackButton = attacksFolder.addButton({
        title: "Play"
      });
      playAttackButton.on("click", () => {
        if (this.selectedAttack === ATTACK_KEYS.SLASH) {
          this.slashAttack.playAnimation();
          return;
        }
        if (this.selectedAttack === ATTACK_KEYS.ICE_SHARD) {
          this.iceShardAttack.playAnimation();
          return;
        }
      });
    }
    updateAttackGameObjectPosition(param, value) {
      if (param === "x") {
        if (this.selectedAttack === ATTACK_KEYS.SLASH) {
          this.slashAttack.getGameObject()?.setX(value);
          return;
        }
        if (this.selectedAttack === ATTACK_KEYS.ICE_SHARD) {
          this.iceShardAttack.getGameObject()?.setX(value);
          return;
        }
      }
      console.log(this.iceShardAttack.getGameObject());
      if (this.selectedAttack === ATTACK_KEYS.SLASH) {
        this.slashAttack.getGameObject()?.setY(value);
        return;
      }
      if (this.selectedAttack === ATTACK_KEYS.ICE_SHARD) {
        this.iceShardAttack.getGameObject()?.setY(value);
      }
    }
  };

  // src/main.ts
  var game = new phaser_default.Game({
    type: phaser_default.CANVAS,
    scale: {
      parent: "game-container",
      width: 1024,
      height: 576,
      mode: phaser_default.Scale.FIT,
      autoCenter: phaser_default.Scale.CENTER_BOTH
    },
    backgroundColor: "#000000"
  });
  game.scene.add(SCENE_KEYS.PRELOAD_SCENE, PreloadScene);
  game.scene.add(SCENE_KEYS.BATTLE_SCENE, TitleScene);
  game.scene.add(SCENE_KEYS.BATTLE_SCENE, OptionsScene);
  game.scene.add(SCENE_KEYS.BATTLE_SCENE, BattleScene);
  game.scene.add(SCENE_KEYS.BATTLE_SCENE, TestScene);
  game.scene.start(SCENE_KEYS.PRELOAD_SCENE);
})();
